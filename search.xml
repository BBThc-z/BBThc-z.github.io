<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微服务保护</title>
      <link href="/2024/08/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/"/>
      <url>/2024/08/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务保护"><a href="#微服务保护" class="headerlink" title="微服务保护"></a>微服务保护</h1><h2 id="一、微服务保护基础"><a href="#一、微服务保护基础" class="headerlink" title="一、微服务保护基础"></a>一、微服务保护基础</h2><h3 id="1-1-雪崩问题的产生原因"><a href="#1-1-雪崩问题的产生原因" class="headerlink" title="1.1 雪崩问题的产生原因"></a>1.1 雪崩问题的产生原因</h3><p>&emsp; 在前面两篇blog中解决了微服务项目中远程调用、网关和配置相关的内容，这已经可以解决微服务项目中大部分的问题了，但是仍存在一些问题，考虑如下场景：<br>&emsp; 一个微服务项目，服务A需要调用服务B提供的服务，但是服务B可能会抛出异常；或者服务B并发量很高，导致服务B响应服务A的时延很长，甚至超时导致查询失败。此时会导致服务A的响应时间很长，若在高并发的场景下，Tomcat连接占用很多，会拖垮服务中其他接口的响应时间。<br>&emsp; 若还有其他服务调用服务A，同样会拖垮调用者服务，这样会导致<strong>级联失败</strong>，产生<strong>雪崩问题</strong>。</p><h3 id="1-2-服务保护方案"><a href="#1-2-服务保护方案" class="headerlink" title="1.2 服务保护方案"></a>1.2 服务保护方案</h3><ul><li>请求限流</li><li>线程隔离</li><li>服务熔断</li></ul><h4 id="请求限流"><a href="#请求限流" class="headerlink" title="请求限流"></a><strong>请求限流</strong></h4><p>&emsp; 产生雪崩问题的原因，归根结底就是并发太高！因此请求限流，就是<strong>限制或控制</strong>接口访问的并发流量，避免服务因流量激增而出现故障。</p><img src="/2024/08/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image.png" class="" title="请求限流"><h4 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a><strong>线程隔离</strong></h4><p>&emsp; 当一个服务接口响应时间长，并且处在高并发状态时，此时会占用大量的Tomcat连接，这样会导致服务内其他接口的请求时延也大大增加。为解决这个问题，可以对服务内的接口设置<strong>占用最大线程数</strong>，这样该服务接口不会大量占用Tomcat连接，可以保护服务内的其他接口。</p><h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a><strong>服务熔断</strong></h4><p>&emsp; 限流和线程隔离策略可以达到对服务内其他接口的保护，但是这种处理策略会让服务调用处堆积大量的请求。<br>&emsp; 服务熔断策略中存在一个<strong>熔断器</strong>，它会统计服务调用的时延和异常次数，若时延过高的响应或者异常次数超过阈值，那么就会中断被请求服务的接口，所有请求走<strong>fallback</strong>逻辑。<br>&emsp; 在这个策略中，需要做两件事：</p><ul><li>监控服务提供接口的异常率或者时延过高的响应；</li><li>便也fallback处理逻辑，一般是返回默认值或者提示</li></ul><h2 id="二、Sentinel"><a href="#二、Sentinel" class="headerlink" title="二、Sentinel"></a>二、Sentinel</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>&emsp; Sentinel是SpringCloudAlibaba提供的一款服务保护框架(<a href="https://sentinelguard.io/zh-cn/docs/introduction.html)%E3%80%82">https://sentinelguard.io/zh-cn/docs/introduction.html)。</a><br>&emsp; 下载好后，通过如下命令就可以运行 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar</span><br></pre></td></tr></table></figure><h3 id="2-2-快速使用"><a href="#2-2-快速使用" class="headerlink" title="2.2 快速使用"></a>2.2 快速使用</h3><ol><li>步骤一：引入sentinel依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>步骤二：添加sentinel board地址配置<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br><span class="line">      <span class="attr">http-method-specify:</span> <span class="literal">true</span> <span class="comment"># 开启请求方式前缀</span></span><br></pre></td></tr></table></figure></li><li>步骤三：OpenFeign整合sentinel<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对sentinel的支持</span></span><br></pre></td></tr></table></figure></li></ol><p>&emsp; 完成以上配置，接下载只需要在sentinel网站上“点点点”就可以实现请求限流和线程隔离啦~</p><h3 id="2-3-线程熔断实现"><a href="#2-3-线程熔断实现" class="headerlink" title="2.3 线程熔断实现"></a>2.3 线程熔断实现</h3><p>&emsp; 在1.3小节中提到过，要实现线程熔断需要完成两件事：监控和编写fallback逻辑代码。在sentinel中只提供了监控功能，剩下的fallback代码需要自己编写。</p><ol><li><p>步骤一：在api模块中编写实现<code>FallbackFactory</code>接口的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemClientFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;ItemClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(Collection&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;远程调用ItemClient#queryItemByIds方法出现异常，参数：&#123;&#125;&quot;</span>, ids, cause);</span><br><span class="line">                <span class="comment">// 查询购物车允许失败，查询失败，返回空集合</span></span><br><span class="line">                <span class="keyword">return</span> CollUtils.emptyList();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(List&lt;OrderDetailDTO&gt; items)</span> &#123;</span><br><span class="line">                <span class="comment">// 库存扣减业务需要触发事务回滚，查询失败，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>步骤二：在配置类中将刚刚编写的fallback注册为一个bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ItemClientFallback <span class="title function_">itemClientFallback</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemClientFallback</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>步骤三：在相应的Client类中的FeignClient注解中配置fallbackFactory属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;,</span></span><br><span class="line"><span class="meta">            fallbackFactory = ItemClientFallback.class,</span></span><br><span class="line"><span class="meta">            configuration = DefaultFeignConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span></span><br></pre></td></tr></table></figure></li><li><p>步骤四：在sentinel中配置熔断规则</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务-网关和配置</title>
      <link href="/2024/08/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BD%91%E5%85%B3%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/08/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BD%91%E5%85%B3%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><h2 id="一、网关快速入门"><a href="#一、网关快速入门" class="headerlink" title="一、网关快速入门"></a>一、网关快速入门</h2><h3 id="1-1-认识网关"><a href="#1-1-认识网关" class="headerlink" title="1.1 认识网关"></a>1.1 认识网关</h3><p>&emsp; 当项目采用微服务架构时，由于每个服务有自己服务器端口，这样产生了以下两个问题：</p><ul><li>后端服务器接口过多，而且后期可能会进行更改或者扩展，因此前端对后端不同服务的请求会很复杂，难以管理；</li><li>微服务的多个服务可能会有登录请求校验，获得用户信息等功能，如果在多个模块中添加相应的功能代码，会导致程序冗余。</li></ul><p>&emsp; 为解决以上问题，就需要一个同一管理后端微服务接口的中间件，这就是路由网关。网关对外暴露一个端口，随后根据请求的URL将请求路由转发给提供相应服务的后端微服务，同时可以在网关设置登录校验等统一功能。</p><img src="/2024/08/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BD%91%E5%85%B3%E5%92%8C%E9%85%8D%E7%BD%AE/image.png" class="" title="网关"><p>&emsp; 在SpringCloud有两种网管实现方案，现在一般采用<code>SpringCloudGateway(https://spring.io/projects/spring-cloud-gateway#learn)</code>的解决方案。</p><h3 id="1-2-使用步骤"><a href="#1-2-使用步骤" class="headerlink" title="1.2 使用步骤"></a>1.2 使用步骤</h3><ol><li>步骤一：创建新模块</li><li>步骤二：引入依赖：SpringCloudGateway、nacos发现以及负载均衡依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos discovery--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--负载均衡--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>步骤三：新建启动类</li><li>步骤四：配置路由：路由信息就是根据接收到前端请求的url来路由转发到已在nacos注册服务的后端微服务地址<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span> <span class="comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span> <span class="comment"># 这里是以请求路径作为判断规则</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-路由过滤"><a href="#1-3-路由过滤" class="headerlink" title="1.3 路由过滤"></a>1.3 路由过滤</h3><p>&emsp; 在网关的配置文件中，需要填写后端微服务的路由信息，其中包括四个信息</p><ul><li>id：唯一标识一个路由的id，可自定义；</li><li>uri：表示微服务的地址，<strong>格式：lb:&#x2F;&#x2F;item-service</strong></li><li>predicates：路由匹配的条件，时key-value结构，可支持的类型有很多</li></ul><img src="/2024/08/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BD%91%E5%85%B3%E5%92%8C%E9%85%8D%E7%BD%AE/image-1.png" class="" title="路由断言"><ul><li>filter：SpringCloudGateway提供了33种过滤器，其中每种过滤器都有独特的功能。若配置在routers下，则只对当前路由生效；如果想对所有路由生效，那么需要一个<code>default-filters</code>属性</li></ul><img src="/2024/08/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BD%91%E5%85%B3%E5%92%8C%E9%85%8D%E7%BD%AE/image-2.png" class="" title="过滤器"><h3 id="1-4-自定义过滤器"><a href="#1-4-自定义过滤器" class="headerlink" title="1.4 自定义过滤器"></a>1.4 自定义过滤器</h3><blockquote><p>自定义过滤器分为两种：<br>GatewayFilter：作用于指定的路由请求，默认不生效，要配置到路由后才生效<br>GlobalFilter：作用范围是所有路由，声明后自动生效</p></blockquote><p><strong>Global过滤器</strong><br>&emsp; 实现<code>GlobalFilter</code>接口的filter方法，用于编写过滤逻辑；实现Ordered接口的getOrder方法，用于表示过滤器的优先级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;未登录，无法访问&quot;</span>);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        <span class="comment">// return chain.filter(exchange);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拦截</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setRawStatusCode(<span class="number">401</span>);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 过滤器执行顺序，值越小，优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GatewayFilter</strong><br>&emsp; 实现<code>AbstractGatewayFilterFactory</code>接口的apply方法，这个实现支持动态配置参数且需要配置后才能生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="comment">// 父类泛型是内部类的Config类型</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;PrintAnyGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="comment">// OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：</span></span><br><span class="line">        <span class="comment">// - GatewayFilter：过滤器</span></span><br><span class="line">        <span class="comment">// - int order值：值越小，过滤器执行优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedGatewayFilter</span>(<span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取config值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> config.getA();</span><br><span class="line">                <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> config.getB();</span><br><span class="line">                <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> config.getC();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">                System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">                System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义配置属性，成员变量名称很重要，下面会用到</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String a;</span><br><span class="line">        <span class="keyword">private</span> String b;</span><br><span class="line">        <span class="keyword">private</span> String c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 返回当前配置类的类型，也就是内部的Config</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;Config&gt; <span class="title function_">getConfigClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Config.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp; 随后在网关配置文件中配置该过滤器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny=1,2,3</span> <span class="comment"># 注意，这里多个参数以&quot;,&quot;隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</span></span><br></pre></td></tr></table></figure><h2 id="二、网关登录校验"><a href="#二、网关登录校验" class="headerlink" title="二、网关登录校验"></a>二、网关登录校验</h2><h3 id="2-1-网关请求处理流程"><a href="#2-1-网关请求处理流程" class="headerlink" title="2.1 网关请求处理流程"></a>2.1 网关请求处理流程</h3><ul><li>前端发送的请求首先会到达网关的路由映射器，这一步会找到与请求匹配的路由</li><li>接下来会到达请求处理器，它将网关中的所有的过滤器根据优先级形成一条过滤器链</li><li>随后依次到达过滤器的pre部分，这是到达微服务前的处理逻辑，微服务给出结果后，还会经过过滤器的post部分。</li></ul><img src="/2024/08/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BD%91%E5%85%B3%E5%92%8C%E9%85%8D%E7%BD%AE/image-3.png" class="" title="网关处理流程"><p>在这过程中，有如下<strong>几个问题待处理</strong>：</p><ul><li>如何在网关将请求转发到微服务前做登陆验证</li><li>网关如何把请求转发给微服务</li><li>微服务间如何传递用户消息</li></ul><h3 id="2-2-登录校验过滤器"><a href="#2-2-登录校验过滤器" class="headerlink" title="2.2 登录校验过滤器"></a>2.2 登录校验过滤器</h3><p>&emsp; 在网关的<code>filter</code>文件夹下新建一个Global校验过滤器，这样解决了<strong>在网关中做登录校验的问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AuthProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtTool jwtTool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthProperties authProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">antPathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取Request</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">// 2.判断是否不需要拦截</span></span><br><span class="line">        <span class="keyword">if</span>(isExclude(request.getPath().toString()))&#123;</span><br><span class="line">            <span class="comment">// 无需拦截，直接放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        List&lt;String&gt; headers = request.getHeaders().get(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!CollUtils.isEmpty(headers)) &#123;</span><br><span class="line">            token = headers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.校验并解析token</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = jwtTool.parseToken(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnauthorizedException e) &#123;</span><br><span class="line">            <span class="comment">// 如果无效，拦截</span></span><br><span class="line">            <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">            response.setRawStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 5.如果有效，传递用户信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;userId = &quot;</span> + userId);</span><br><span class="line">        <span class="comment">// 6.放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isExclude</span><span class="params">(String antPath)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String pathPattern : authProperties.getExcludePaths()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(antPathMatcher.match(pathPattern, antPath))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在登陆校验中用到了token，用到了ConfigurationProperties(prefix &#x3D; “hm.jwt”)注解，该注解可以获取到配置文件的数据，只需要制定好配置文件中的前缀即可</p></blockquote><h3 id="2-3-网关传送用户消息给微服务"><a href="#2-3-网关传送用户消息给微服务" class="headerlink" title="2.3 网关传送用户消息给微服务"></a>2.3 网关传送用户消息给微服务</h3><p>&emsp; 在上一小节完成的登录校验过滤器中，对请求头中的token进行了检验，对检验成功的token提取出了UserId，但是并没有将UserId传送给下游微服务。<br>&emsp; 在filter方法中的exchange参数包含了http请求的所有内容，因此可以将UserId通过exchange保存到请求头中，再传递给下游服务，于是需要将上一小节第5步修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 传递用户信息到微服务中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> userId.toString();</span><br><span class="line"><span class="type">ServerWebExchange</span> <span class="variable">swe</span> <span class="operator">=</span> exchange.mutate()</span><br><span class="line">        .request(builder -&gt; builder.header(<span class="string">&quot;user-info&quot;</span>, userInfo))</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">// 6. 返回</span></span><br><span class="line"><span class="keyword">return</span> chain.filter(swe);</span><br></pre></td></tr></table></figure><p>&emsp; 刚刚只是在网关部分将用户信息保存到请求头中并发送给了下游微服务，因此在微服务中需要定义一个过滤器读取请求头中的用户信息保存到ThreadLocal中。<br>&emsp; 而所有微服务都需要或许用户信息，因此我们在common模块中定义一个过滤器，这样所有的微服务都可以通过该过滤器获得用户信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserInfoInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp; 由于过滤器实现比较简单，因此这里没有给出具体代码。而在过滤器注册代码中，需要注意一点，由于gateway也用到了common模块的部分功能，但是gateway模块并没有引入springMVC的依赖，因此需要加上<code>@ConditionalOnClass(DispatcherServlet.class)</code>注解，代表这个过滤器只在含有SpringMVC的模块中生效。</p><h3 id="2-4-微服务之间传递用户信息"><a href="#2-4-微服务之间传递用户信息" class="headerlink" title="2.4 微服务之间传递用户信息"></a>2.4 微服务之间传递用户信息</h3><p>&emsp; 经过以上步骤，前端对某一个微服务发起的请求，已经可以通过网关进行身份校验，路由转发，下游微服务可以也可以正确接收到网管转发的包含用户信息的请求。<br>&emsp; 但是当微服务之间有调用关系时，此时可能需要传递用户信息，这个步骤是通过feign发送http请求完成的，但是在发送该请求时并没有添加用户信息。为解决这个问题，只需要实现<code>feign.RequestInterceptor</code>接口的apply方法即可，可以通过该方法中template参数提供的方法来对请求头做各种各样的修改。<br>&emsp; 这里为了方便，在统一接口<code>hm-api</code>中使用匿名内部类的方法实现。每一次通过feign发起http微服务内部请求时都会自动调用该接口中apply方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoRequestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取登录用户</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line">            <span class="keyword">if</span>(userId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果为空则直接跳过</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不为空则放入请求头中，传递给下游微服务</span></span><br><span class="line">            template.header(<span class="string">&quot;user-info&quot;</span>, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、配置管理"><a href="#三、配置管理" class="headerlink" title="三、配置管理"></a>三、配置管理</h2><h3 id="3-1-spring-cloud配置文件管理"><a href="#3-1-spring-cloud配置文件管理" class="headerlink" title="3.1 spring-cloud配置文件管理"></a>3.1 spring-cloud配置文件管理</h3><p>&emsp; 在SpringCloud项目中，首先会尝试加载<code>bootstrap.yml</code>文件，随后尝试拉取nacos中的配置，随后加载<code>application.yml</code>文件，最后合并两个配置文件。</p><img src="/2024/08/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BD%91%E5%85%B3%E5%92%8C%E9%85%8D%E7%BD%AE/image-5.png" class="" title="spring-cloud配置"><h3 id="3-2-共享配置"><a href="#3-2-共享配置" class="headerlink" title="3.2 共享配置"></a>3.2 共享配置</h3><p>&emsp; 在所有微服务的配置文件中，有很多共享的配置信息，例如数据库mysql、mybatis-plus以及日志文件的配置，我们可以通过nacos提供的共享配置功能来简化配置文件</p><ol><li><p>步骤一：首先在提取出微服务中的共享配置，并将配置添加到微服务的配置管理列表中，相当于完成配置的注册</p><img src="/2024/08/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BD%91%E5%85%B3%E5%92%8C%E9%85%8D%E7%BD%AE/image-4.png" class="" title="配置注册"></li><li><p>步骤二：从nacos中拉取共享配置信息</p><ol><li>引入nacos配置管理依赖以及读取bootstarp文件的依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>在<code>bootstrap.yaml</code>文件中配置如下信息，包括服务名称、nacos地址以及共享配置ID<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cart-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.223</span><span class="number">.101</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="attr">shared-configs:</span> <span class="comment"># 共享配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-jdbc.yaml</span> <span class="comment"># 共享mybatis配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-swagger.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure></li><li>删除<code>application.yaml</code>文件中荣誉的配置</li></ol></li></ol><h3 id="3-3-配置热更新"><a href="#3-3-配置热更新" class="headerlink" title="3.3 配置热更新"></a>3.3 配置热更新</h3><p>&emsp; 在3.1小节中，提到了会拉取nacos配置，在这一步中除了会拉取在<code>bootstrap.yaml</code>文件中配置的共享文件，还会尝试拉取以下两个文件，分别是：</p><ul><li>[服务名]-[spring.active.profile].[后缀名]</li><li>[服务名].[后缀名]</li></ul><p><strong>步骤</strong></p><ol><li><p>步骤一：在nacos配置管理中添加一个ID符合上述名称的配置文件</p><img src="/2024/08/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BD%91%E5%85%B3%E5%92%8C%E9%85%8D%E7%BD%AE/image-6.png" class="" title="配置热更新配置"></li><li><p>步骤二：在cart-service的config包下读取配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;hm.cart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer maxAmount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务-远程调用</title>
      <link href="/2024/08/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
      <url>/2024/08/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="一、微服务与单体架构"><a href="#一、微服务与单体架构" class="headerlink" title="一、微服务与单体架构"></a>一、微服务与单体架构</h2><h3 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1 单体架构"></a>1.1 单体架构</h3><ol><li><p>定义：一个项目所有功能模块都在一个工程中开发，项目的部署和开发比较简单</p></li><li><p>缺点：</p><ul><li>团队协作成本高</li><li>系统的发布效率差：一个项目的任意一个模块的bug都会导致整个项目需要重新编译部署</li><li>系统可用性差：各模块之间会互相影响，一个热点的功能会耗尽大部分的服务器资源，导致其他功能模块服务低可用</li></ul></li></ol><h3 id="1-2-微服务"><a href="#1-2-微服务" class="headerlink" title="1.2 微服务"></a>1.2 微服务</h3><ol><li>定义：将一个项目中的不同模块拆分出来，独立部署为多个服务。</li><li>特点：<ul><li>单一职责：一个微服务负责一部分业务功能，核心模块不依赖其他模块</li><li>团队自治：每个微服务有自己的一整套开发、测试、运维等人员</li><li>服务自治：每个服务独立打包、部署，访问自己独立的数据库。</li></ul></li></ol><h3 id="1-3-SpringCloud"><a href="#1-3-SpringCloud" class="headerlink" title="1.3 SpringCloud"></a>1.3 SpringCloud</h3><blockquote><p>SpringCloud是一个标准规范，其并不提供具体的服务，而SpringCloudAlibaba是一个满足SpringCloud规范的微服务框架的具体实现，它提供了具体的解决方案。两者关系类似于接口和实现类</p></blockquote><p><strong>使用方法</strong><br>&emsp; 在父工程里面引入SpringCloud和SpringCloudAlibaba的依赖管理，这样有关这两个依赖的版本就无需配置了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>2021.0.3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud-alibaba.version</span>&gt;</span>2021.0.4.0<span class="tag">&lt;/<span class="name">spring-cloud-alibaba.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring cloud--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring cloud alibaba--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、服务拆分和调用"><a href="#二、服务拆分和调用" class="headerlink" title="二、服务拆分和调用"></a>二、服务拆分和调用</h2><p>&emsp; 当一个项目是微服务架构时，难免会出现一个服务调用另一个服务功能的情况，那么此时就需要跨微服务的远程调用(RPC)</p><p>&emsp; 此时由于微服务不在同一个模块中，并且每个微服务独立访问自己的数据库，服务之间不能直接通过对象调用，那么就需要http请求来调用服务接口，Spring提供了一个RestTemplate的API可以方便的发送http请求。</p><h3 id="2-1-RestTemplate"><a href="#2-1-RestTemplate" class="headerlink" title="2.1 RestTemplate"></a>2.1 RestTemplate</h3><p><strong>使用方法</strong></p><ol><li>步骤一：创建一个config类，将<code>RestTemplate</code>注册为一个bean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteCallConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>步骤二：使用<code>RestTemplate</code>提供的exchange方法向其他服务发送http请求<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">        <span class="string">&quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">        HttpMethod.GET,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;&#125;,</span><br><span class="line">        Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 解析响应</span></span><br><span class="line"><span class="keyword">if</span>(!response.getStatusCode().is2xxSuccessful())&#123;</span><br><span class="line">    <span class="comment">// 查询失败，直接结束</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;ItemDTO&gt; items = response.getBody();</span><br><span class="line"><span class="keyword">if</span> (CollUtils.isEmpty(items)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、服务注册和发现"><a href="#三、服务注册和发现" class="headerlink" title="三、服务注册和发现"></a>三、服务注册和发现</h2><p>&emsp; 上一小节使用restTemplate实现了对其他服务的远程调用，但是在代码中将发送http请求的IP和端口写“死”了，这样后面对服务进行多机部署时，只能访问其中一台服务器，没有进行负载均衡。</p><h3 id="3-1-Nacos基本情况"><a href="#3-1-Nacos基本情况" class="headerlink" title="3.1 Nacos基本情况"></a>3.1 Nacos基本情况</h3><p>&emsp; 为了解决上述问题，需要一个能够管理所有所有服务的中间件，而Nacos就是这样一个中间件，它可以管理所有对外提供服务接口的服务器地址，并将服务推送到需要的服务中。</p><img src="/2024/08/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/image.png" class="" title="Nacos"><p><strong>基本情况</strong></p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul><p><strong>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</strong></p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><h3 id="3-2-Nacos部署"><a href="#3-2-Nacos部署" class="headerlink" title="3.2 Nacos部署"></a>3.2 Nacos部署</h3><p>&emsp; 这里是用的是docker容器部署，Nacos部署需要一个使用到mysql数据库，同时有一个<code>nacos/custom.env</code>文件，里面包含mysql的地址信息，下面是mysql的表信息内容以及配置文件内容 <strong>(注：Nacos要在mysql之后启动，否则会连接不上nacos)</strong></p><img src="/2024/08/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/image-1.png" class="" title="Nacos数据库表信息"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PREFER_HOST_MODE=hostname</span><br><span class="line">MODE=standalone</span><br><span class="line">SPRING_DATASOURCE_PLATFORM=mysql</span><br><span class="line">MYSQL_SERVICE_HOST=192.168.223.101</span><br><span class="line">MYSQL_SERVICE_DB_NAME=nacos</span><br><span class="line">MYSQL_SERVICE_PORT=3306</span><br><span class="line">MYSQL_SERVICE_USER=root</span><br><span class="line">MYSQL_SERVICE_PASSWORD=123</span><br><span class="line">MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure><p>&emsp; 随后使用docker进行部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name nacos \</span><br><span class="line">--env-file ./nacos/custom.env \</span><br><span class="line">-p 8848:8848 \</span><br><span class="line">-p 9848:9848 \</span><br><span class="line">-p 9849:9849 \</span><br><span class="line">--restart=always \</span><br><span class="line">nacos/nacos-server:v2.1.0-slim</span><br></pre></td></tr></table></figure><h3 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3 服务注册"></a>3.3 服务注册</h3><p>&emsp; nacos部署完成后，可以通过<code>8848</code>端口访问测试，若成功部署，接下来就是在java中使用nacos提供的服务。<br>&emsp; 首先是服务注册，若一个服务需要对外提供服务接口，那么就需要在Nacos中注册，分为以下两步：</p><ol><li>步骤一：引入Nacos依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>步骤二：配置Nacos<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4 服务发现"></a>3.4 服务发现</h3><p>&emsp; 服务的消费者需要订阅服务，此时有以下三步：</p><ol><li>步骤一：引入Nacos依，与服务注册依赖一致<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>步骤二：配置Nacos地址，服务发现不依赖服务名称，但是一般来说也会配置服务名称<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure></li><li>步骤三：使用SpringCloud提供的<code>DiscoveryClient</code>发现服务，随后进行负载均衡，再调用<code>restTemplate</code>进行发起http请求。<strong>这里与直接使用restTemplate不同的地方是，首先发现所有的服务实例，随后获取一个实例，最后通过实例获取服务的ip地址和端口号</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.1 发现服务的所有实例</span></span><br><span class="line">List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;item-service&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 使用负载均衡算法选择一个实例</span></span><br><span class="line"><span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> instances.get(RandomUtil.randomInt(instances.size()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.3 向商品管理微服务发起http请求</span></span><br><span class="line">ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">        instance.getUri() + <span class="string">&quot;/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">        HttpMethod.GET,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;&#125;,</span><br><span class="line">        Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><h2 id="四、OpenFeign"><a href="#四、OpenFeign" class="headerlink" title="四、OpenFeign"></a>四、OpenFeign</h2><p>&emsp; 上一小节使用了Nacos实现了服务治理，也就是其中管理所有提供服务接口的服务地址，但是使用起来比较复杂，而OpenFeign组件可以大大简化RPC的过程。</p><h3 id="4-1-快速入门"><a href="#4-1-快速入门" class="headerlink" title="4.1 快速入门"></a>4.1 快速入门</h3><ol><li><p>步骤一：创建一个新模块<code>hm-api</code>，专门用来提供所有服务接口的。<strong>创建这个模块的目的是可能多个模块都需要调用同一个服务的接口，这样可以提供一个统一的服务接口，不用每个模块都创建服务接口</strong></p></li><li><p>步骤二：需要引入两个依赖，一个是OpenFeign，另一个是负载均衡依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--openFeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>步骤三：在使用服务接口的启动类上添加注解，启用OpenFeign功能，其中basePackages的值是统一服务接口的包名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;)</span></span><br></pre></td></tr></table></figure></li><li><p>步骤四：编写OpenFeign客户端，在<code>hm-api</code>模块中新建client包，创建如下接口(示例)<br>该接口指明了服务提供者的服务名称<br>对应的方法上有请求路径和参数以及返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>步骤五：服务消费者引入<code>hm-api</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--feign模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>步骤六：服务消费者创建<code>ItemClient</code>对象，并通过该对象调用在<code>hm-api</code>中声明的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;CartMapper, Cart&gt; <span class="keyword">implements</span> <span class="title class_">ICartService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ItemClient itemClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCartItems</span><span class="params">(List&lt;CartVO&gt; vos)</span> &#123;</span><br><span class="line">       List&lt;ItemDTO&gt; items = itemClient.queryItemsByIds(itemIds);</span><br><span class="line"></span><br><span class="line">        Map&lt;Long, ItemDTO&gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity()));</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (CartVO v : vos) &#123;</span><br><span class="line">            <span class="type">ItemDTO</span> <span class="variable">item</span> <span class="operator">=</span> itemMap.get(v.getItemId());</span><br><span class="line">            <span class="keyword">if</span> (item == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v.setNewPrice(item.getPrice());</span><br><span class="line">            v.setStatus(item.getStatus());</span><br><span class="line">            v.setStock(item.getStock());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-2-配置连接池"><a href="#4-2-配置连接池" class="headerlink" title="4.2 配置连接池"></a>4.2 配置连接池</h3><p>&emsp; OpenFeign发起http请求时使用的http客户端基于<code>HttpURLConnection</code>，该http客户端不支持连接池，效率较低，因此配置为支持连接池的<code>OKHttp</code></p><ol><li><p>步骤一：在服务消费者中引入OKHttp客户端的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>步骤二：配置连接池生效</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基础入门</title>
      <link href="/2024/08/16/docker%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
      <url>/2024/08/16/docker%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="docker基础入门"><a href="#docker基础入门" class="headerlink" title="docker基础入门"></a>docker基础入门</h1><blockquote><p>以下内容基于centOS-7，镜像传送门：<a href="https://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-2009.iso">https://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-2009.iso</a></p></blockquote><h2 id="一、docker安装"><a href="#一、docker安装" class="headerlink" title="一、docker安装"></a>一、docker安装</h2><h3 id="1-1-卸载旧版"><a href="#1-1-卸载旧版" class="headerlink" title="1.1 卸载旧版"></a>1.1 卸载旧版</h3><p>&emsp; 尝试卸载旧版，如果存在就卸载，不存在也没有影响，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-engine \</span><br><span class="line">    docker-selinux </span><br></pre></td></tr></table></figure><h3 id="1-2-配置docker的yum库"><a href="#1-2-配置docker的yum库" class="headerlink" title="1.2 配置docker的yum库"></a>1.2 配置docker的yum库</h3><p>&emsp; 首先安装yum工具，这里安装了三个包，其中<code>-y</code>代表安装中所有询问都默认为‘yes’</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>&emsp; 配置docker的yum源(这里使用阿里源)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27;</span> /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure><ul><li><code>sed</code>是一个流编辑器；</li><li><code>-i</code> 表示就地修改；</li><li><code>/etc/yum.repos.d/docker-ce.repo</code>代表要修改的文件名路径</li><li><code>s+download.docker.com+mirrors.aliyun.com/docker-ce+</code>:s是sed的替换指令，+起到分割的作用</li></ul><p>&emsp; 更新yum，建立缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum makecache fast</span><br></pre></td></tr></table></figure><h3 id="1-3-安装docker"><a href="#1-3-安装docker" class="headerlink" title="1.3 安装docker"></a>1.3 安装docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><h3 id="1-4-启动和校验"><a href="#1-4-启动和校验" class="headerlink" title="1.4 启动和校验"></a>1.4 启动和校验</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动docker</span></span><br><span class="line">systemctl start docker </span><br><span class="line"></span><br><span class="line"><span class="comment">#设置开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不报错，说明docker启动成功</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="1-5-docker镜像加速器"><a href="#1-5-docker镜像加速器" class="headerlink" title="1.5 docker镜像加速器"></a>1.5 docker镜像加速器</h3><p>&emsp; 24年6月国内大部分的docker镜像加速器都被关闭，包括阿里云的服务，不过好在华为云的还可以使用。搜索华为云的“容器镜像服务”，获得自己的镜像加速网址，随后使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加速地址改成自己的</span></span><br><span class="line"><span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">         <span class="string">&quot;https://xxx.mirror.swr.myhuaweicloud.com&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启Docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="二、docker架构"><a href="#二、docker架构" class="headerlink" title="二、docker架构"></a>二、docker架构</h2><img src="/2024/08/16/docker%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image.png" class="" title="docker架构"><p>&emsp; 开启docker的服务后，在docker Server中会有一个守护进程dicker daemon时刻监听Client端发出的命令。<br>&emsp; 在docker内存在本地镜像仓库images和容器container，本地镜像仓库保存从外部镜像仓库下载的镜像(所谓镜像，就是一个包含运行环境和已经解压好的软件安装包内容)。container则是对于对于镜像的运行实例，每当使用run命令就会开启一个新的container实例，一个image可以同时有多个container实例来实现集群效果。<br>&emsp; 在docker中，每一个container其实是一个小型的虚拟机，每一个container都有完整的linux文件系统、网络系统等</p><h2 id="二、docker常见命令"><a href="#二、docker常见命令" class="headerlink" title="二、docker常见命令"></a>二、docker常见命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><ul><li><code>docker run</code>：创建并运行一个容器；<ul><li><code>-d</code>：表示容器在后台运行；</li><li><code>--name</code>：容器的名字，必须唯一；</li><li><code>-p xxx:yyy</code>：端口映射，xxx是运行docker机器的端口，yyy是容器虚拟机的端口；</li><li><code>-e</code>：环境配置，不同的软件部署有不同的环境配置；</li><li><code>mysql</code>：全称是<code>Repository:TAG</code>，前面是镜像名称，后面是相应的版本号，忽略版本号则默认下载最新的。</li></ul></li><li><code>docker pull nginx</code>：从远程仓库下载镜像nginx</li><li><code>docker images</code>：查看本地所有镜像</li><li><code>docker save [-o nginx.tar] nginx:latest</code>:保存镜像到本地<ul><li><code>-o</code>：保存文件的名称</li></ul></li><li><code>docker load -i nginx.tar</code>：上传本地文件到docker</li><li><code>docker ps [--format ···]</code>：查看所有已经运行的容器<ul><li><code>--format</code>：格式化输出</li></ul></li><li><code>docker ps -a</code>：查看所有容器</li><li><code>docker stop nginx</code>：停止nginx服务，但是nginx的container还存在</li><li><code>docker start nginx</code>：开启nginx服务，但是不创建容器，容器已经存在</li><li><code>docker logs [-f] nginx</code>：查看日志，<code>-f</code>是持续查看日志，会阻塞当前进程</li><li><code>docker exec -it nginx bash</code>：以bash命令行模式进入nginx服务虚拟机</li><li><code>docker rm nginx [-f]</code>：删除nginx的container，image还存在<ul><li><code>-f</code>：强制删除服务未停止的容器</li></ul></li><li><code>docker rmi nginx</code>：删除镜像</li></ul><blockquote><p>命令别名<br>通过修改~&#x2F;.bashrc文件，可实现命令别名<br><code>alias dockerfmt=&#39;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#39;</code></p></blockquote><h2 id="三、资源挂载"><a href="#三、资源挂载" class="headerlink" title="三、资源挂载"></a>三、资源挂载</h2><p>&emsp; 由于镜像内环境是一个程序运行的最小环境，所以不含有类似于<code>vi</code>等命令，因此直接对容器内的文件数据等资源进行修改或添加比较困难，故需要用到挂载。<br>&emsp; 挂载使得宿主机的某一文件或文件夹与容器内的文件或文件夹产生双向关联，此时就可以通过操作宿主机的文件来修改容器内的文件。</p><h3 id="3-1-数据卷挂载"><a href="#3-1-数据卷挂载" class="headerlink" title="3.1 数据卷挂载"></a>3.1 数据卷挂载</h3><ol><li>数据卷：是一个虚拟目录，使容器内目录与宿主机目录之间映射的桥梁。数据卷宿主机目录固定为<code>/var/lib/docker/volumes</code></li></ol><img src="/2024/08/16/docker%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-1.png" class="" title="数据卷结构"><ol start="2"><li>数据卷相关命令</li></ol><img src="/2024/08/16/docker%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-2.png" class="" title="数据卷命令"><blockquote><ul><li>只有在使用<code>docker run</code>是才可以进行挂载</li><li>挂载时，若数据卷不存在，则会自动创建数据卷</li></ul></blockquote><p><strong>挂载命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name nginx \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  -v html:/usr/share/nginx/html \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><h3 id="3-2-本地目录挂载"><a href="#3-2-本地目录挂载" class="headerlink" title="3.2 本地目录挂载"></a>3.2 本地目录挂载</h3><p>&emsp; 数据卷挂载的宿主机目录是固定的，而本地目录挂载可以实现在宿主机的任意目录下进行挂载，增加了灵活性。</p><p><strong>挂载命令</strong></p><figure class="highlight plaintext"><figcaption><span>本地目录:容器内目录```：注意本地目录需要以/或者./开头，否则会被认为是数据卷挂载</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 四、构建镜像</span><br><span class="line">### 4.1 自定义镜像</span><br><span class="line">**定义**</span><br><span class="line">&amp;emsp; 镜像就是包含了应用程序、程序运行的系统函数库、运行配置等文件的文件包。构建镜像的过程就是把上述文件打包的过程。</span><br><span class="line"></span><br><span class="line">**镜像结构**</span><br><span class="line">- 一个镜像可能包含多个镜像的压缩包，例如环境压缩包、程序压缩包等。例如一个centOS-7环境的镜像可能会被很多其他镜像作为环境使用，这样就形成了镜像的**层**结构。</span><br><span class="line">- 基础镜像：应用依赖的系统库函数、环境、配置等</span><br><span class="line">- 入口：镜像的运行入口，一般是程序的脚本和参数</span><br><span class="line"></span><br><span class="line">### 4.2 Dockerfile</span><br><span class="line">&amp;emsp; Dockerfile是一个包含**指令**的文本文件，Docker可以根据编写的Dockerfile自动构建镜像。Dockerfile的常见指令如下：</span><br><span class="line">&#123;% asset_img image-3.png Dockerfile常见指令 %&#125;</span><br><span class="line"></span><br><span class="line">**一个简单的Dockerfile例子**</span><br><span class="line">```Dockerfile</span><br><span class="line"># 基础镜像</span><br><span class="line">FROM openjdk:11.0-jre-buster</span><br><span class="line">#拷贝jar包到镜像</span><br><span class="line">COPY docker-demo.jar /app.jar</span><br><span class="line">#镜像入口</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure><h3 id="4-3-构建镜像"><a href="#4-3-构建镜像" class="headerlink" title="4.3 构建镜像"></a>4.3 构建镜像</h3><p>&emsp; 前面的Dockerfile相当于构建镜像的自动化脚本，此时还需要通过docker运行这个脚本就可以成功构建镜像，镜像的构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 镜像名:版本号 .</span><br></pre></td></tr></table></figure><ul><li>说明：最后的‘.’表示Dockerfile所在的目录，‘.’表示在当前目录下</li></ul><h3 id="4-4-项目部署"><a href="#4-4-项目部署" class="headerlink" title="4.4 项目部署"></a>4.4 项目部署</h3><p>&emsp; 当部署一个项目时，可能会有前端、后端、各种中间件，这时如果分别进行部署可能会导致遗漏。因此提出了DockerCompose，对一个完整的项目，只需编写docker-compose.yml，该文件中包含所有容易的配置信息。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><p><strong>docker-compose常见命令</strong></p><img src="/2024/08/16/docker%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-5.png" class="" title="docker-compose常见命令"><h2 id="五、容器网络"><a href="#五、容器网络" class="headerlink" title="五、容器网络"></a>五、容器网络</h2><h3 id="5-1-默认配置"><a href="#5-1-默认配置" class="headerlink" title="5.1 默认配置"></a>5.1 默认配置</h3><p>&emsp; 在默认情况下，当启动docker服务时会自动创建一个默认的虚拟网卡<strong>docker0</strong>，所有启动的容器会默认的通过网桥连接到默认的虚拟网卡。</p><h3 id="5-2-自定义网络"><a href="#5-2-自定义网络" class="headerlink" title="5.2 自定义网络"></a>5.2 自定义网络</h3><p>&emsp; 可以通过<code>create</code>创建网络，随后通过<code>connect</code>将某些容器加入到网络，或者可以在<code>docker run</code>指令中添加<code>--network</code>来初始化网络，如果网络进行初始化，那么该容器将不会连接到默认的网卡上</p><h4 id="自定义网络的优势"><a href="#自定义网络的优势" class="headerlink" title="自定义网络的优势"></a><strong>自定义网络的优势</strong></h4><p>&emsp; 在默认的网络下，容器之间之可以通过IP来互相访问，而容器的IP地址会发生变化，这样可能会导致容器之间无法找到对方。<br>&emsp; 在自定义的网络中，除了可以通过IP访问其他容器，还可以通过<strong>容器名</strong>进行访问，这样可以解决容器之间找不到对方的问题。</p><img src="/2024/08/16/docker%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-4.png" class="" title="网络指令">]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马点评项目总结(下)</title>
      <link href="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8B/"/>
      <url>/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="五、消息队列"><a href="#五、消息队列" class="headerlink" title="五、消息队列"></a>五、消息队列</h2><h3 id="5-1-异步阻塞队列对秒杀的优化"><a href="#5-1-异步阻塞队列对秒杀的优化" class="headerlink" title="5.1 异步阻塞队列对秒杀的优化"></a>5.1 异步阻塞队列对秒杀的优化</h3><h4 id="5-1-1-前言"><a href="#5-1-1-前言" class="headerlink" title="5.1.1 前言"></a>5.1.1 前言</h4><p>&emsp; 前面实现的优惠券秒杀业务流程，从判断库存是否充足，是否有购买资格知道最后于数据库的交互都是线性执行的，但是和数据库的交互会消耗大量时间，降低了效率。</p><h4 id="5-1-2-异步思路"><a href="#5-1-2-异步思路" class="headerlink" title="5.1.2 异步思路"></a>5.1.2 异步思路</h4><p>&emsp; 由于与数据库交互浪费时间，因此可以把这部分的代码交给一个新开辟的线程去处理。那么如何取到每一个订单呢？<br>&emsp; 在下单前的种种判断逻辑处理比较快，交给主线程处理，若用户拥有购买资格且库存充足，那么生成一个订单ID，并将给订单ID添加到一个阻塞队列里；开辟的子线程时刻监听阻塞队列，一旦取到订单ID就会于数据库交互执行相应的业务代码。<br>&emsp; 下图是主线程执行的业务逻辑，其中不包括与数据库打交道的部分。</p><img src="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8B/image.png" class="" title="alt text"><p>&emsp; 与数据库交互的部分：首先开辟一个线程池，线程池的任务就是监听阻塞队列，一旦取到了订单ID就与数据库进行交互。<br>&emsp; 由于业务中对多个数据库进行了修改，因此需要添加事务，因此如果直接调用方法又会出现事务失效的问题，因此需要通过获得代理对象，间接调用方法。但是获取代理对象是基于当前线程的，因此无法在开辟的子线程中获得代理对象，需要在主线程中获得代理对象。</p><h4 id="5-1-3-效果"><a href="#5-1-3-效果" class="headerlink" title="5.1.3 效果"></a>5.1.3 效果</h4><p>&emsp; 使用非异步方法，在1s内1000个线程的测试下，吞吐率由1000&#x2F;s提升至1400&#x2F;s，吞吐率提升了<strong>40%<strong>；而请求的平均响应时长由400ms缩短至200ms，平均响应时长缩短了</strong>100%</strong></p><h3 id="5-2-redis消息队列实现异步秒杀"><a href="#5-2-redis消息队列实现异步秒杀" class="headerlink" title="5.2 redis消息队列实现异步秒杀"></a>5.2 redis消息队列实现异步秒杀</h3><h4 id="5-2-1-认识消息队列"><a href="#5-2-1-认识消息队列" class="headerlink" title="5.2.1 认识消息队列"></a>5.2.1 认识消息队列</h4><p>&emsp; 消息队列有<strong>三个角色组成</strong>，分别是：</p><ul><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获得消息并处理消息</li><li>消息队列：存储和管理消息</li></ul><p>&emsp; redis实现消息队列有<strong>三种方式</strong>：</p><ul><li>List：利用LPUSH和RPOP或者RPUSH和LPOP结合实现<ul><li>优点：<ul><li>支持数据持久化</li><li>可以满足消息的有序性</li></ul></li><li>缺点：<ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul></li></ul></li><li>PubSub：消费者可以订阅多个channel，生产者相对应channel发送消息后，所有订阅者都能收到消息。<ul><li>优点：<ul><li>支持多生产、多消费</li></ul></li><li>缺点：<ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消费者缓存区有上限，超出时数据会丢失</li></ul></li></ul></li><li>stream单消费模式：Redis 5.0引入的数据类型，专门为实现消息队列而生<ul><li>优点：<ul><li>消息可回溯</li><li>支持多消费</li><li>可以阻塞读取</li></ul></li><li>缺点：<ul><li>有消息漏读风险，由于是读取最新的消息，当正在处理一条消息时，有超过1条以上的消息发送到消息队列，此时会漏读消息</li></ul></li></ul></li><li>stream消费者组：将多个消费者划分到同一个组里面，监听同一个队列。<ul><li>特点：<ul><li>消息分流：队列中的消息会分配给组内不同的消费者，提高消费效率</li><li>消息标示：消费者组内会维护一个消息标示，记录最后一个被处理的消息，确保了消息不会被漏读</li><li>消息确认：消费者获取消息后，消息处于pending状态，并存入pending-list中，当消息处理完成后，需要通过ack来确认消息被处理，随后从pending-list移除。</li></ul></li><li>优点：在stream单消费的基础上，还有如下优点<ul><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li><li>组内多消费者，提升消费效率</li></ul></li></ul></li></ul><img src="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8B/image-1.png" class="" title="alt text"><h4 id="5-2-2-使用stream消费者组实现消息队列的思路"><a href="#5-2-2-使用stream消费者组实现消息队列的思路" class="headerlink" title="5.2.2 使用stream消费者组实现消息队列的思路"></a>5.2.2 使用stream消费者组实现消息队列的思路</h4><p>&emsp; 使用stream消费者组消费消息时，使用’&gt;’来获取消息队列中下一个未消费消息；当该阶段出现异常时，需要使用’0’来获取pending-list中的消息，并处理pending-list中的消息直到结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;          </span><br><span class="line">        <span class="comment">// 尝试监听，使用阻塞模式，最多2000ms</span></span><br><span class="line">        List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                StreamOffset.create(MQ_KEY, ReadOffset.lastConsumed())</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 队列不存在消息，continue</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理消息，处理完记得ack</span></span><br><span class="line">        stringRedisTemplate.opsForStream().acknowledge(MQ_KEY, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 出现异常，处理pending-list中的消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从pending-list中获取消息</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                        Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                        StreamOffset.create(MQ_KEY, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断队列中是否存在消息</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 队列不存在消息，continue</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 消费消息</span></span><br><span class="line">                <span class="comment">// 4. ack</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(MQ_KEY, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;消费pending-list消息错误！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、Redis其他数据类型应用"><a href="#六、Redis其他数据类型应用" class="headerlink" title="六、Redis其他数据类型应用"></a>六、Redis其他数据类型应用</h2><h3 id="6-1-用set集合实现用户对商铺点赞的记录"><a href="#6-1-用set集合实现用户对商铺点赞的记录" class="headerlink" title="6.1 用set集合实现用户对商铺点赞的记录"></a>6.1 用set集合实现用户对商铺点赞的记录</h3><h4 id="6-1-1-背景"><a href="#6-1-1-背景" class="headerlink" title="6.1.1 背景"></a>6.1.1 背景</h4><p>&emsp; 正常情况下，一个用户对一篇博客只能点赞一次；若用户对一片博客已经点过赞了，则再次点赞会取消点赞。</p><h4 id="6-1-2-实现"><a href="#6-1-2-实现" class="headerlink" title="6.1.2 实现"></a>6.1.2 实现</h4><p>&emsp; 使用redis的set集合记录每一篇博客点赞的用户ID，每次可通过该集合判断用户是否已经点过赞。随后根据从redis查询的数据进行后续操作</p><h4 id="6-1-3-进一步实现点赞排行榜"><a href="#6-1-3-进一步实现点赞排行榜" class="headerlink" title="6.1.3 进一步实现点赞排行榜"></a>6.1.3 进一步实现点赞排行榜</h4><p>&emsp; 使用redis的zset集合，每一位用户点赞的score值是时间戳，zset会根据score值进行排序，最后呈现的结果为点赞顺序为用户点赞的时间</p><h3 id="6-2-使用set集合实现共同关注功能"><a href="#6-2-使用set集合实现共同关注功能" class="headerlink" title="6.2 使用set集合实现共同关注功能"></a>6.2 使用set集合实现共同关注功能</h3><p>&emsp; 针对每一位用户，应用redis的set集合保存其所有关注的用户ID，这样想查询两个用户共同关注的用户时，使用交集即可达成目的。</p><h3 id="6-3-使用feed流实现自动接收关注博主文章"><a href="#6-3-使用feed流实现自动接收关注博主文章" class="headerlink" title="6.3 使用feed流实现自动接收关注博主文章"></a>6.3 使用feed流实现自动接收关注博主文章</h3><h4 id="6-3-1-基础实现"><a href="#6-3-1-基础实现" class="headerlink" title="6.3.1 基础实现"></a>6.3.1 基础实现</h4><p>&emsp; 每当用户发送一篇文章时，针对每一个粉丝，会向redis中的set集合存入带有时间戳的博客ID，当粉丝用户上线后，会从自己的set集合中取出所有的博客。</p><h4 id="6-3-2-实现分页收件箱"><a href="#6-3-2-实现分页收件箱" class="headerlink" title="6.3.2 实现分页收件箱"></a>6.3.2 实现分页收件箱</h4><p>&emsp; 根据前端提供的上一次查询的最后一个时间戳以及偏移量实现分页查询</p><h3 id="6-4-使用Geo数据类型实现范围内查找功能"><a href="#6-4-使用Geo数据类型实现范围内查找功能" class="headerlink" title="6.4 使用Geo数据类型实现范围内查找功能"></a>6.4 使用Geo数据类型实现范围内查找功能</h3><h3 id="6-5-使用bitMap实现用户签到并统计连续签到天数功能"><a href="#6-5-使用bitMap实现用户签到并统计连续签到天数功能" class="headerlink" title="6.5 使用bitMap实现用户签到并统计连续签到天数功能"></a>6.5 使用bitMap实现用户签到并统计连续签到天数功能</h3><h3 id="6-6-使用hyperloglog实现UV统计"><a href="#6-6-使用hyperloglog实现UV统计" class="headerlink" title="6.6 使用hyperloglog实现UV统计"></a>6.6 使用hyperloglog实现UV统计</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 项目经历 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马点评项目总结(中)</title>
      <link href="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%AD/"/>
      <url>/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="三、优惠券秒杀"><a href="#三、优惠券秒杀" class="headerlink" title="三、优惠券秒杀"></a>三、优惠券秒杀</h2><h3 id="3-1-全局ID生成器"><a href="#3-1-全局ID生成器" class="headerlink" title="3.1 全局ID生成器"></a>3.1 全局ID生成器</h3><h4 id="3-1-1-原因"><a href="#3-1-1-原因" class="headerlink" title="3.1.1 原因"></a>3.1.1 原因</h4><p>&emsp; 受限于单表的存储能力，分表会导致重复ID，同时要保证ID的安全性，无法使用数据库的自增字段</p><h4 id="3-1-2-生成方式"><a href="#3-1-2-生成方式" class="headerlink" title="3.1.2 生成方式"></a>3.1.2 生成方式</h4><p>&emsp; 当系统是分布式系统时，也需要满足全局ID唯一，因此采用Redis生成全局唯一ID。为保证安全性，需要将redis自增的数值拼接一些其他内容，具体生成策略如下：</p><ul><li>第一位为符号位</li><li>接下来的31位用时间戳填满，以秒为单位</li><li>最后32位是自增序列号，每秒内可支持2^32^个ID<img src="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%AD/image-10.png" class="" title="全局唯一ID"></li></ul><h4 id="3-1-3-其他全局唯一ID生成策略"><a href="#3-1-3-其他全局唯一ID生成策略" class="headerlink" title="3.1.3 其他全局唯一ID生成策略"></a>3.1.3 其他全局唯一ID生成策略</h4><ul><li>UUID</li><li>snowflake算法 <em>(算法在附录中)</em></li><li>数据库自增</li></ul><h3 id="3-2-实现秒杀下单"><a href="#3-2-实现秒杀下单" class="headerlink" title="3.2 实现秒杀下单"></a>3.2 实现秒杀下单</h3><h4 id="3-2-1-业务流程"><a href="#3-2-1-业务流程" class="headerlink" title="3.2.1 业务流程"></a>3.2.1 业务流程</h4><img src="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%AD/image-11.png" class="" title="秒杀业务流程"><h4 id="3-2-2-存在的问题"><a href="#3-2-2-存在的问题" class="headerlink" title="3.2.2 存在的问题"></a>3.2.2 存在的问题</h4><p>&emsp; 在当前的实现中，会产生多卖问题，这属于多线程安全问题。为解决此问题，需要给当前业务加锁。</p><blockquote><p>乐观锁 vs 悲观锁</p><ul><li>乐观锁：<ul><li>认为线程安全问题不一定会发生，因此不会加锁，只会在更新数据时检查数据有没有被其他线程修改。</li></ul></li><li>悲观锁：<ul><li>认为线程安全问题一定会发生，因此在代码执行前先获取锁，保证线程串行执行。</li></ul></li></ul></blockquote><h4 id="3-2-3-解决方案及代码实现"><a href="#3-2-3-解决方案及代码实现" class="headerlink" title="3.2.3 解决方案及代码实现"></a>3.2.3 解决方案及代码实现</h4><p>&emsp; 本项目采用乐观锁解决<strong>超卖问题</strong>，乐观锁一般有两种实现方式：</p><ul><li>版本号法：每次更新数据时查询数据库中的版本号和先前查询的版本号是否一致，不一致证明数据已被其他线程修改过；若一致，则更新数据和版本号</li><li>CAS(compare and switch)法：利用数据库中的一个字段代替版本号<br>以下代码是乐观锁的CAS代码实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">                .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                .update();</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-实现一人一单"><a href="#3-3-实现一人一单" class="headerlink" title="3.3 实现一人一单"></a>3.3 实现一人一单</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 一户一单，判断用户是否已经购买过</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-1-出现的问题"><a href="#3-3-1-出现的问题" class="headerlink" title="3.3.1 出现的问题"></a>3.3.1 出现的问题</h4><p>&emsp; 由于对于秒杀券订单的增加在上述代码后面实现，因此可能会出现一个ID第一个抢购秒杀券的订单还未写入到数据库中，此时同ID的另一个线程执行上述代码，导致查询到的结果与实际不符，最终一个用户ID购买了多个秒杀券。</p><h4 id="3-3-2-解决方案"><a href="#3-3-2-解决方案" class="headerlink" title="3.3.2 解决方案"></a>3.3.2 解决方案</h4><p>&emsp; 由于乐观锁只能针对更新操作，本操作是添加操作，因此使用悲观锁解决。锁的对象是每个用户ID，范围是从判断用户是否下过单直到添加订单到数据库。</p><h4 id="3-3-3-实现过程中出现的问题"><a href="#3-3-3-实现过程中出现的问题" class="headerlink" title="3.3.3 实现过程中出现的问题"></a>3.3.3 实现过程中出现的问题</h4><p>&emsp; 项目中将加锁的部分抽出形成一个方法B，在原方法A中调用了方法B。由于方法B中对数据库的两个表进行的修改，因此添加了事务，由于锁需要在事务提交后进行释放，因此锁是加到方法A中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法A</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().intern();</span><br><span class="line">    <span class="keyword">synchronized</span>(userId.toString().intern()) &#123;</span><br><span class="line">      <span class="keyword">return</span> getResult(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法B</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getResult</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 包含了判断用户是否下过单以及对两个数据库的修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp; 在上述代码实现中，会导致方法B的事务失效。原因如下：在spring中，@Transactional注解是基于动态代理实现的，事务的实现由代理对象管理。在上面的代码中，直接使用方法名称调用方法B，实际是<code>this.getResult()</code>，没有通过代理对象调用，因此方法B的事务不会生效。</p><h4 id="3-3-4-对该问题的解决"><a href="#3-3-4-对该问题的解决" class="headerlink" title="3.3.4 对该问题的解决"></a>3.3.4 对该问题的解决</h4><p>&emsp; 若想解决事务失效的问题，首先需要获取到本类的代理对象，随后通过代理对象调用方法B。具体代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法A</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().intern();</span><br><span class="line">        <span class="keyword">synchronized</span>(userId.toString().intern()) &#123;</span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.getResult(voucherId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法B</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getResult</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">// 包含了判断用户是否下过单以及对两个数据库的修改</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="四、分布式锁"><a href="#四、分布式锁" class="headerlink" title="四、分布式锁"></a>四、分布式锁</h2><h3 id="4-1-服务器集群模式下的线程安全问题"><a href="#4-1-服务器集群模式下的线程安全问题" class="headerlink" title="4.1 服务器集群模式下的线程安全问题"></a>4.1 服务器集群模式下的线程安全问题</h3><h4 id="4-1-1-问题描述"><a href="#4-1-1-问题描述" class="headerlink" title="4.1.1 问题描述"></a>4.1.1 问题描述</h4><p>&emsp; 由于每一个jvm都有自己的锁监视器，因此当后端服务器是集群模式的情况时，同一时刻同一用户不同线程访问不同的后端服务器，都会获得锁，故针对“一人一单”的锁就会失效。</p><h4 id="4-1-2-使用redis实现分布式锁"><a href="#4-1-2-使用redis实现分布式锁" class="headerlink" title="4.1.2 使用redis实现分布式锁"></a>4.1.2 使用redis实现分布式锁</h4><p>&emsp; 使用redis的setnx命令即可实现分布式锁，下面是一个使用redis实现分布式锁的样例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> ID_PREFIX +  Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + key, value, timeoutSec, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">myLock</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisLock</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (myLock.equals(redisLock)) &#123;</span><br><span class="line">            stringRedisTemplate.delete(KEY_PREFIX + key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp; 在该分布式锁的实现过程中，需要注意一下几个问题：</p><ul><li>设置锁的超时施放时间，可以防止因线程拿到锁后迟迟不释放锁导致出现死锁的问题。</li><li>使用随机前缀 + 线程ID作为锁的value，原因有两个：<ul><li>当线程需要释放锁时，首先获取锁的value，与自己的线程ID作比较，可以判断自己的锁是否已经释放，防止误释放其他线程锁的情况</li><li>由于后端是集群模式，因此线程ID可能会有重复，因此需要随机前缀保证不同后端服务器的不同线程保存锁的value值不重复</li></ul></li></ul><h4 id="4-1-3-实现过程中的问题及解决"><a href="#4-1-3-实现过程中的问题及解决" class="headerlink" title="4.1.3 实现过程中的问题及解决"></a>4.1.3 实现过程中的问题及解决</h4><ul><li>由于在释放锁时，判断锁的value和自己现成的id是否相等与释放锁的操作不是原子性的，因此可能会出现线程安全问题<ul><li>使用lua脚本可以实现对redis操作的原子性，代码实现如下：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line">end</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在上述分布式锁代码的基础上的修改和添加</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.execute(UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + key),</span><br><span class="line">                ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-redisson工具"><a href="#4-2-redisson工具" class="headerlink" title="4.2 redisson工具"></a>4.2 redisson工具</h3><h4 id="4-2-1-书写的redis分布式锁的缺点"><a href="#4-2-1-书写的redis分布式锁的缺点" class="headerlink" title="4.2.1 书写的redis分布式锁的缺点"></a>4.2.1 书写的redis分布式锁的缺点</h4><ul><li>不可重入：同一个线程无法多次获取同一把锁</li><li>不可重试：获取锁失败就会返回false，没有重试机会</li><li>超时释放：线程任务未完成也会释放锁，存在安全隐患</li><li>主从一致性：redis集群可能会导致锁被多个线程获取，当然这种可能性极低</li></ul><h4 id="4-2-2-redisson的使用"><a href="#4-2-2-redisson的使用" class="headerlink" title="4.2.2 redisson的使用"></a>4.2.2 redisson的使用</h4><p>&emsp; redisson提供了一系列分布式的java常用对象，其中包括各种分布式锁的实现，下面是使用redisson的步骤：</p><ul><li>引入redisson依赖<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>配置redisson客户端<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.223.101:6379&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用redissonClient调用redisson方法</li></ul><h4 id="4-2-3-redisson解决上述四个问题的原理"><a href="#4-2-3-redisson解决上述四个问题的原理" class="headerlink" title="4.2.3 redisson解决上述四个问题的原理"></a>4.2.3 redisson解决上述四个问题的原理</h4><ul><li>可重入：<ul><li>redisson使用redis的hash数据解决来存储一把锁，当一个线程获取锁成功时，会将hash的value + 1，hash结构中的value代表该锁被获取的个数。</li></ul></li></ul><img src="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%AD/image-12.png" class="" title="redisson锁"><ul><li><p>可重试：</p><ul><li>使用redis的消息订阅以及信号量的机制实现。当获取锁失败，线程会在自己设置的等待时间内等待其他线程释放锁，若该时间段内其他现车给释放了锁，则会使用消息队列的机制发送给当前线程一条消息，该线程就可以再次尝试获取锁；否则将会返回false。</li></ul></li><li><p>不会超时释放</p><ul><li>当调用获取锁的方法时，如果给leaseTime赋值，那么会开启Watchdog机制，该机制可以无限期给当前线程任务重置超时时间直到锁释放</li></ul></li></ul><img src="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%AD/image.png" class="" title="alt text"><ul><li>主从一致性分布式锁<ul><li>当redis是主从集群模式时，需要使用multiLock，该方法需要获取所有独立的redis节点上的锁，才算获取锁成功</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 项目经历 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马点评项目总结(上)</title>
      <link href="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/"/>
      <url>/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="黑马点评项目技术总结"><a href="#黑马点评项目技术总结" class="headerlink" title="黑马点评项目技术总结"></a>黑马点评项目技术总结</h1><h2 id="一、基于Redis实现发送短信验证码功能"><a href="#一、基于Redis实现发送短信验证码功能" class="headerlink" title="一、基于Redis实现发送短信验证码功能"></a>一、基于Redis实现发送短信验证码功能</h2><h3 id="1-1-基于session实现发送短信验证码功能流程"><a href="#1-1-基于session实现发送短信验证码功能流程" class="headerlink" title="1.1 基于session实现发送短信验证码功能流程"></a>1.1 基于session实现发送短信验证码功能流程</h3><h4 id="1-1-1-发送短信验证码"><a href="#1-1-1-发送短信验证码" class="headerlink" title="1.1.1 发送短信验证码"></a>1.1.1 发送短信验证码</h4><p>  若用户使用手机号 + 短信验证码的方式进行登录，当用户点击获取验证码时，会向后台发送一条请求，下图就是后台对该请求的处理流程：</p><ol><li>校验手机号</li><li>生成验证码</li><li>保存验证码到session(用于后续校验)</li><li>发送验证码到用户手机  <img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-1.png" class="" title="图片"></li></ol><h4 id="1-1-2-短信验证码登录、注册"><a href="#1-1-2-短信验证码登录、注册" class="headerlink" title="1.1.2 短信验证码登录、注册"></a>1.1.2 短信验证码登录、注册</h4><p>  这一步是用户点击登录按钮发送到后端的请求，后端对该请求的处理流程，具体如下：</p><ol><li>校验手机号(这一步是防止用户在登陆前修改手机号)</li><li>根据第一步保存到session的验证码与前端发送的验证码比对</li><li>判断用户是否已注册</li><li>将用户保存到session中，为后续其他网页的校验做准备  <img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-2.png" class="" title="alt text"></li></ol><h4 id="1-1-3-校验登陆状态"><a href="#1-1-3-校验登陆状态" class="headerlink" title="1.1.3 校验登陆状态"></a>1.1.3 校验登陆状态</h4><p>  为了实现对用户的每一个页面访问进行校验的功能，此时需要用到拦截器，在拦截器中对http请求携带的cookie以及保存在session中的信息进行比较。拦截器的实现以及拦截器和过滤器的区别将在后文进行说明。<br>  若存在用户，则将脱敏后的用户信息保存到ThreadLocal中，由于每一个session都是一个线程，因此只要不关闭页面，那么以后每次对后端的请求都可以从ThreadLocal中获取本次session的用户信息。<br>  <img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-3.png" class="" title="alt text"></p><h3 id="1-2-集群的session的共享问题"><a href="#1-2-集群的session的共享问题" class="headerlink" title="1.2 集群的session的共享问题"></a>1.2 集群的session的共享问题</h3><h4 id="1-2-1-问题"><a href="#1-2-1-问题" class="headerlink" title="1.2.1 问题"></a>1.2.1 问题</h4><p>  由于session时保存在后端服务器内存中，且多台服务器无法共享session。因此这在实际的后端服务器集群模式下，会产生用户在服务器A登录保存到session登陆凭证，再次访问服务器B时无法得到登录的信息凭证的问题。</p><h4 id="1-2-2-解决方案"><a href="#1-2-2-解决方案" class="headerlink" title="1.2.2 解决方案"></a>1.2.2 解决方案</h4><p>  为解决集群下session的共享问题，设计的方案需要满足以下几点要求：</p><ol><li>数据共享</li><li>内存存储</li><li>key-value结构</li></ol><p>  redis恰好满足上述所有的要求，因此使用redis来保存验证码信息以及用户登录的authorization。</p><h4 id="1-2-3-具体实现"><a href="#1-2-3-具体实现" class="headerlink" title="1.2.3 具体实现"></a>1.2.3 具体实现</h4><p>  将保存到session中的验证码和用户登录的authorization保存到redis中即可，同时用户每一次对网站的访问，都会刷新登录的authorization的有效期；在用户登陆成功后，及时将登陆的验证码从redis中删除。</p><h3 id="附：拦截器的实现"><a href="#附：拦截器的实现" class="headerlink" title="附：拦截器的实现"></a>附：拦截器的实现</h3><ol><li><p>创建一个类实现HandlerInterceptor接口，重写preHandle方法，afterCompletion可根据需求自定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个实现WebMvcConfigurer接口的类，重写其中的addInterceptors方法，该类中可以配置所有的拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意不要忘记注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span></span><br><span class="line">                )</span><br><span class="line">                .order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// order越小越靠前</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="二、商户查询缓存"><a href="#二、商户查询缓存" class="headerlink" title="二、商户查询缓存"></a>二、商户查询缓存</h2><h3 id="2-1-缓存前置"><a href="#2-1-缓存前置" class="headerlink" title="2.1 缓存前置"></a>2.1 缓存前置</h3><h4 id="2-1-1-缓存的作用"><a href="#2-1-1-缓存的作用" class="headerlink" title="2.1.1 缓存的作用"></a>2.1.1 缓存的作用</h4><ul><li>降低后端负载</li><li>提高读写效率、降低延迟时间</li></ul><h4 id="2-1-2-缓存的成本"><a href="#2-1-2-缓存的成本" class="headerlink" title="2.1.2 缓存的成本"></a>2.1.2 缓存的成本</h4><ul><li>数据一致性成本</li><li>代码维护成本</li><li>运维成本</li></ul><p>本项目对查询的店铺信息添加的缓存，降低了访问店铺的响应时间</p><h3 id="2-2-缓存更新策略"><a href="#2-2-缓存更新策略" class="headerlink" title="2.2 缓存更新策略"></a>2.2 缓存更新策略</h3><p>&emsp; 当数据更新到数据库时，如何保证缓存中的数据与数据库中的数据保持一致性，此时需要考虑缓存的更新策略，一般有如下三种缓存更新策略：</p><img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-4.png" class="" title="alt text"><ul><li>当一致性需求低时，可以考虑使用redis自带的内存淘汰机制</li><li>若需要高一致性需求，则可以使用主动更新，配合超时剔除作为兜底方法</li></ul><p>&emsp; 当使用主动更新策略时，需要注意以下<strong>三个问题</strong>：</p><ul><li><em>数据更新时，删除缓存还是更新缓存？</em><ul><li>应该选择<strong>删除缓存</strong>，当查询数据时再将数据从数据库中读入缓存中，这样可以避免更新是对缓存无效的写操作。</li></ul></li><li>如何保证缓存与数据库的操作同时成功或者失败？<ul><li>当项目是单体项目时，将对缓存和数据库的操作放在一个事务内；</li><li>若时分布式系统，则可以采用分布式事务解决方案。</li></ul></li><li>先操作缓存还是数据库？<ul><li>先操作数据库随后再删除缓存。由于对数据的操作耗时较长，当删除缓存后，有另一个线程需要访问该数据，此时会向缓存中写入还未更新的数据，导致缓存和数据库的数据不一致</li></ul></li></ul><h3 id="2-3-缓存穿透"><a href="#2-3-缓存穿透" class="headerlink" title="2.3 缓存穿透"></a>2.3 缓存穿透</h3><h4 id="2-3-1-什么是缓存穿透"><a href="#2-3-1-什么是缓存穿透" class="headerlink" title="2.3.1 什么是缓存穿透"></a>2.3.1 什么是缓存穿透</h4><p>&emsp; 客户端请求的数据在缓存和数据库中都不存在，这会使得缓存永远不生效，所有请求都会到数据库层操作，给数据库带来巨大压力。</p><h4 id="2-3-2-解决方案"><a href="#2-3-2-解决方案" class="headerlink" title="2.3.2 解决方案"></a>2.3.2 解决方案</h4><img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-5.png" class="" title="alt text"><ul><li><p>缓存空对象</p><ul><li>对于缓存击穿查询的对象也保存一份空对象到缓存中，这样以后的请求就可以从缓存中查到</li><li>优点：<ul><li>实现简单，维护方便</li></ul></li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的数据不一致性，当缓存中的数据是空对象时，此时恰好为插入了一条该数据到数据库中。</li></ul></li></ul></li><li><p>布隆过滤</p><ul><li>在请求redis缓存前，先到布隆过滤器中查询是否有该数据，如果没有则拒绝本次请求 <em>（算法在附录中）</em></li><li>优点：<ul><li>内存占用较少</li></ul></li><li>缺点：<ul><li>实现复杂</li><li>存在误判的可能，会出现不存在的数据被误判为存在</li></ul></li></ul></li><li><p>增加id的复杂度，避免被猜测id的规律</p></li><li><p>做好数据的基础格式校验</p></li></ul><h3 id="2-4-缓存雪崩"><a href="#2-4-缓存雪崩" class="headerlink" title="2.4 缓存雪崩"></a>2.4 缓存雪崩</h3><h4 id="2-4-1-什么是缓存雪崩？"><a href="#2-4-1-什么是缓存雪崩？" class="headerlink" title="2.4.1 什么是缓存雪崩？"></a>2.4.1 什么是缓存雪崩？</h4><p>&emsp; 同一时间段内缓存中的大量key同时失效或者redis服务器宕机，导致大量请求到达数据库</p><h4 id="2-4-2-解决方案"><a href="#2-4-2-解决方案" class="headerlink" title="2.4.2 解决方案"></a>2.4.2 解决方案</h4><ul><li>给不同的key添加随机的TTL值，可以防止redis中的key同时失效</li><li>利用redis集群提高服务的可用性</li><li>添加多级缓存</li><li>给业务添加降级限流策略</li></ul><h3 id="2-5-缓存击穿"><a href="#2-5-缓存击穿" class="headerlink" title="2.5 缓存击穿"></a>2.5 缓存击穿</h3><h4 id="2-5-1-什么是缓存击穿"><a href="#2-5-1-什么是缓存击穿" class="headerlink" title="2.5.1 什么是缓存击穿"></a>2.5.1 什么是缓存击穿</h4><p>&emsp; 也称热点key问题，一个被<strong>高并发访问</strong>且<strong>缓存重建困难</strong>的key失效，导致大量的请求被发送到数据库，且同时进行大量的缓存重建操作</p><h4 id="2-5-2-解决方案"><a href="#2-5-2-解决方案" class="headerlink" title="2.5.2 解决方案"></a>2.5.2 解决方案</h4><ul><li>互斥锁<ul><li>第一个查询到缓存失效的线程获取到锁并对数据进行缓存重建，其他线程无法获取到锁进行休眠</li><li>优点<ul><li>没有额外的内存损耗</li><li>保证一致性</li><li>实现简单</li></ul></li><li>缺点<ul><li>其他没有获取到锁的线程需要等待，效率降低<img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-8.png" class="" title="互斥锁"></li></ul></li></ul></li><li>逻辑过期<ul><li>每一条热点数据实际上在内存中永不过期，但会存储一个逻辑过期时间。当查询到逻辑过期时间到期后，会开启一个线程进行异步缓存重建，缓存重建期间对该数据的所有查询都会返回旧值。</li><li>优点<ul><li>线程无需等待，性能较好</li></ul></li><li>缺点<ul><li>缓存重建期间，查询的数据不保证一致性</li><li>异步重建缓存会造成一定的内存损耗</li><li>实现复杂<img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-9.png" class="" title="逻辑过期"></li></ul></li></ul></li><li><strong>互斥锁的实现</strong><ul><li>使用redis中的setnx即可</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 项目经历 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
