<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>黑马点评项目总结(下)</title>
      <link href="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8B/"/>
      <url>/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="五、消息队列"><a href="#五、消息队列" class="headerlink" title="五、消息队列"></a>五、消息队列</h2><h3 id="5-1-异步阻塞队列对秒杀的优化"><a href="#5-1-异步阻塞队列对秒杀的优化" class="headerlink" title="5.1 异步阻塞队列对秒杀的优化"></a>5.1 异步阻塞队列对秒杀的优化</h3><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><p>&emsp; 前面实现的优惠券秒杀业务流程，从判断库存是否充足，是否有购买资格知道最后于数据库的交互都是线性执行的，但是和数据库的交互会消耗大量时间，降低了效率。</p><h4 id="2-异步思路"><a href="#2-异步思路" class="headerlink" title="2. 异步思路"></a>2. 异步思路</h4><p>&emsp; 由于与数据库交互浪费时间，因此可以把这部分的代码交给一个新开辟的线程去处理。那么如何取到每一个订单呢？<br>&emsp; 在下单前的种种判断逻辑处理比较快，交给主线程处理，若用户拥有购买资格且库存充足，那么生成一个订单ID，并将给订单ID添加到一个阻塞队列里；开辟的子线程时刻监听阻塞队列，一旦取到订单ID就会于数据库交互执行相应的业务代码。<br>&emsp; 下图是主线程执行的业务逻辑，其中不包括与数据库打交道的部分。</p><img src="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8B/image.png" class="" title="alt text"><p>&emsp; 与数据库交互的部分：首先开辟一个线程池，线程池的任务就是监听阻塞队列，一旦取到了订单ID就与数据库进行交互。<br>&emsp; 由于业务中对多个数据库进行了修改，因此需要添加事务，因此如果直接调用方法又会出现事务失效的问题，因此需要通过获得代理对象，间接调用方法。但是获取代理对象是基于当前线程的，因此无法在开辟的子线程中获得代理对象，需要在主线程中获得代理对象。</p><h4 id="3-效果"><a href="#3-效果" class="headerlink" title="3. 效果"></a>3. 效果</h4><p>&emsp; 使用非异步方法，在1s内1000个线程的测试下，吞吐率由1000&#x2F;s提升至1400&#x2F;s，吞吐率提升了<strong>40%<strong>；而请求的平均响应时长由400ms缩短至200ms，平均响应时长缩短了</strong>100%</strong></p><h3 id="5-2-redis消息队列实现异步秒杀"><a href="#5-2-redis消息队列实现异步秒杀" class="headerlink" title="5.2 redis消息队列实现异步秒杀"></a>5.2 redis消息队列实现异步秒杀</h3><h4 id="1-认识消息队列"><a href="#1-认识消息队列" class="headerlink" title="1. 认识消息队列"></a>1. 认识消息队列</h4><p>&emsp; 消息队列有<strong>三个角色组成</strong>，分别是：</p><ul><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获得消息并处理消息</li><li>消息队列：存储和管理消息</li></ul><p>&emsp; redis实现消息队列有<strong>三种方式</strong>：</p><ul><li>List：利用LPUSH和RPOP或者RPUSH和LPOP结合实现<ul><li>优点：<ul><li>支持数据持久化</li><li>可以满足消息的有序性</li></ul></li><li>缺点：<ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul></li></ul></li><li>PubSub：消费者可以订阅多个channel，生产者相对应channel发送消息后，所有订阅者都能收到消息。<ul><li>优点：<ul><li>支持多生产、多消费</li></ul></li><li>缺点：<ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消费者缓存区有上限，超出时数据会丢失</li></ul></li></ul></li><li>stream单消费模式：Redis 5.0引入的数据类型，专门为实现消息队列而生<ul><li>优点：<ul><li>消息可回溯</li><li>支持多消费</li><li>可以阻塞读取</li></ul></li><li>缺点：<ul><li>有消息漏读风险，由于是读取最新的消息，当正在处理一条消息时，有超过1条以上的消息发送到消息队列，此时会漏读消息</li></ul></li></ul></li><li>stream消费者组：将多个消费者划分到同一个组里面，监听同一个队列。<ul><li>特点：<ul><li>消息分流：队列中的消息会分配给组内不同的消费者，提高消费效率</li><li>消息标示：消费者组内会维护一个消息标示，记录最后一个被处理的消息，确保了消息不会被漏读</li><li>消息确认：消费者获取消息后，消息处于pending状态，并存入pending-list中，当消息处理完成后，需要通过ack来确认消息被处理，随后从pending-list移除。</li></ul></li><li>优点：在stream单消费的基础上，还有如下优点<ul><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li><li>组内多消费者，提升消费效率</li></ul></li></ul></li></ul><img src="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8B/image-1.png" class="" title="alt text"><h4 id="2-使用stream消费者组实现消息队列的思路"><a href="#2-使用stream消费者组实现消息队列的思路" class="headerlink" title="2. 使用stream消费者组实现消息队列的思路"></a>2. 使用stream消费者组实现消息队列的思路</h4><p>&emsp; 使用stream消费者组消费消息时，使用’&gt;’来获取消息队列中下一个未消费消息；当该阶段出现异常时，需要使用’0’来获取pending-list中的消息，并处理pending-list中的消息直到结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;          </span><br><span class="line">        <span class="comment">// 尝试监听，使用阻塞模式，最多2000ms</span></span><br><span class="line">        List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                StreamOffset.create(MQ_KEY, ReadOffset.lastConsumed())</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 队列不存在消息，continue</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理消息，处理完记得ack</span></span><br><span class="line">        stringRedisTemplate.opsForStream().acknowledge(MQ_KEY, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 出现异常，处理pending-list中的消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从pending-list中获取消息</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                        Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                        StreamOffset.create(MQ_KEY, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断队列中是否存在消息</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 队列不存在消息，continue</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 消费消息</span></span><br><span class="line">                <span class="comment">// 4. ack</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(MQ_KEY, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;消费pending-list消息错误！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、Redis其他数据类型应用"><a href="#六、Redis其他数据类型应用" class="headerlink" title="六、Redis其他数据类型应用"></a>六、Redis其他数据类型应用</h2><h3 id="6-1-用set集合实现用户对商铺点赞的记录"><a href="#6-1-用set集合实现用户对商铺点赞的记录" class="headerlink" title="6.1 用set集合实现用户对商铺点赞的记录"></a>6.1 用set集合实现用户对商铺点赞的记录</h3><h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h4><p>&emsp; 正常情况下，一个用户对一篇博客只能点赞一次；若用户对一片博客已经点过赞了，则再次点赞会取消点赞。</p><h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h4><p>&emsp; 使用redis的set集合记录每一篇博客点赞的用户ID，每次可通过该集合判断用户是否已经点过赞。随后根据从redis查询的数据进行后续操作</p><h4 id="3-进一步实现点赞排行榜"><a href="#3-进一步实现点赞排行榜" class="headerlink" title="3. 进一步实现点赞排行榜"></a>3. 进一步实现点赞排行榜</h4><p>&emsp; 使用redis的zset集合，每一位用户点赞的score值是时间戳，zset会根据score值进行排序，最后呈现的结果为点赞顺序为用户点赞的时间</p><h3 id="6-2-使用set集合实现共同关注功能"><a href="#6-2-使用set集合实现共同关注功能" class="headerlink" title="6.2 使用set集合实现共同关注功能"></a>6.2 使用set集合实现共同关注功能</h3><p>&emsp; 针对每一位用户，应用redis的set集合保存其所有关注的用户ID，这样想查询两个用户共同关注的用户时，使用交集即可达成目的。</p><h3 id="6-3-使用feed流实现自动接收关注博主文章"><a href="#6-3-使用feed流实现自动接收关注博主文章" class="headerlink" title="6.3 使用feed流实现自动接收关注博主文章"></a>6.3 使用feed流实现自动接收关注博主文章</h3><h4 id="1-基础实现"><a href="#1-基础实现" class="headerlink" title="1. 基础实现"></a>1. 基础实现</h4><p>&emsp; 每当用户发送一篇文章时，针对每一个粉丝，会向redis中的set集合存入带有时间戳的博客ID，当粉丝用户上线后，会从自己的set集合中取出所有的博客。</p><h4 id="2-实现分页收件箱"><a href="#2-实现分页收件箱" class="headerlink" title="2. 实现分页收件箱"></a>2. 实现分页收件箱</h4><p>&emsp; 根据前端提供的上一次查询的最后一个时间戳以及偏移量实现分页查询</p><h3 id="6-4-使用Geo数据类型实现范围内查找功能"><a href="#6-4-使用Geo数据类型实现范围内查找功能" class="headerlink" title="6.4 使用Geo数据类型实现范围内查找功能"></a>6.4 使用Geo数据类型实现范围内查找功能</h3><h3 id="6-5-使用bitMap实现用户签到并统计连续签到天数功能"><a href="#6-5-使用bitMap实现用户签到并统计连续签到天数功能" class="headerlink" title="6.5 使用bitMap实现用户签到并统计连续签到天数功能"></a>6.5 使用bitMap实现用户签到并统计连续签到天数功能</h3><h3 id="6-6-使用hyperloglog实现UV统计"><a href="#6-6-使用hyperloglog实现UV统计" class="headerlink" title="6.6 使用hyperloglog实现UV统计"></a>6.6 使用hyperloglog实现UV统计</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 项目经历 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马点评项目总结(中)</title>
      <link href="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%AD/"/>
      <url>/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="三、优惠券秒杀"><a href="#三、优惠券秒杀" class="headerlink" title="三、优惠券秒杀"></a>三、优惠券秒杀</h2><h3 id="3-1-全局ID生成器"><a href="#3-1-全局ID生成器" class="headerlink" title="3.1 全局ID生成器"></a>3.1 全局ID生成器</h3><h4 id="1-原因"><a href="#1-原因" class="headerlink" title="1. 原因"></a>1. 原因</h4><p>&emsp; 受限于单表的存储能力，分表会导致重复ID，同时要保证ID的安全性，无法使用数据库的自增字段</p><h4 id="2-生成方式"><a href="#2-生成方式" class="headerlink" title="2. 生成方式"></a>2. 生成方式</h4><p>&emsp; 当系统是分布式系统时，也需要满足全局ID唯一，因此采用Redis生成全局唯一ID。为保证安全性，需要将redis自增的数值拼接一些其他内容，具体生成策略如下：</p><ul><li>第一位为符号位</li><li>接下来的31位用时间戳填满，以秒为单位</li><li>最后32位是自增序列号，每秒内可支持2^32^个ID<img src="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%AD/image-10.png" class="" title="全局唯一ID"></li></ul><h4 id="3-其他全局唯一ID生成策略"><a href="#3-其他全局唯一ID生成策略" class="headerlink" title="3. 其他全局唯一ID生成策略"></a>3. 其他全局唯一ID生成策略</h4><ul><li>UUID</li><li>snowflake算法 <em>(算法在附录中)</em></li><li>数据库自增</li></ul><h3 id="3-2-实现秒杀下单"><a href="#3-2-实现秒杀下单" class="headerlink" title="3.2 实现秒杀下单"></a>3.2 实现秒杀下单</h3><h4 id="1-业务流程"><a href="#1-业务流程" class="headerlink" title="1. 业务流程"></a>1. 业务流程</h4><img src="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%AD/image-11.png" class="" title="秒杀业务流程"><h4 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h4><p>&emsp; 在当前的实现中，会产生多卖问题，这属于多线程安全问题。为解决此问题，需要给当前业务加锁。</p><blockquote><p>乐观锁 vs 悲观锁</p><ul><li>乐观锁：<ul><li>认为线程安全问题不一定会发生，因此不会加锁，只会在更新数据时检查数据有没有被其他线程修改。</li></ul></li><li>悲观锁：<ul><li>认为线程安全问题一定会发生，因此在代码执行前先获取锁，保证线程串行执行。</li></ul></li></ul></blockquote><h4 id="3-解决方案及代码实现"><a href="#3-解决方案及代码实现" class="headerlink" title="3. 解决方案及代码实现"></a>3. 解决方案及代码实现</h4><p>&emsp; 本项目采用乐观锁解决<strong>超卖问题</strong>，乐观锁一般有两种实现方式：</p><ul><li>版本号法：每次更新数据时查询数据库中的版本号和先前查询的版本号是否一致，不一致证明数据已被其他线程修改过；若一致，则更新数据和版本号</li><li>CAS(compare and switch)法：利用数据库中的一个字段代替版本号<br>以下代码是乐观锁的CAS代码实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">                .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                .update();</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-实现一人一单"><a href="#3-3-实现一人一单" class="headerlink" title="3.3 实现一人一单"></a>3.3 实现一人一单</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 一户一单，判断用户是否已经购买过</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="1-出现的问题"><a href="#1-出现的问题" class="headerlink" title="1. 出现的问题"></a>1. 出现的问题</h4><p>&emsp; 由于对于秒杀券订单的增加在上述代码后面实现，因此可能会出现一个ID第一个抢购秒杀券的订单还未写入到数据库中，此时同ID的另一个线程执行上述代码，导致查询到的结果与实际不符，最终一个用户ID购买了多个秒杀券。</p><h4 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h4><p>&emsp; 由于乐观锁只能针对更新操作，本操作是添加操作，因此使用悲观锁解决。锁的对象是每个用户ID，范围是从判断用户是否下过单直到添加订单到数据库。</p><h4 id="3-实现过程中出现的问题"><a href="#3-实现过程中出现的问题" class="headerlink" title="3. 实现过程中出现的问题"></a>3. 实现过程中出现的问题</h4><p>&emsp; 项目中将加锁的部分抽出形成一个方法B，在原方法A中调用了方法B。由于方法B中对数据库的两个表进行的修改，因此添加了事务，由于锁需要在事务提交后进行释放，因此锁是加到方法A中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法A</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().intern();</span><br><span class="line">    <span class="keyword">synchronized</span>(userId.toString().intern()) &#123;</span><br><span class="line">      <span class="keyword">return</span> getResult(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法B</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getResult</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 包含了判断用户是否下过单以及对两个数据库的修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp; 在上述代码实现中，会导致方法B的事务失效。原因如下：在spring中，@Transactional注解是基于动态代理实现的，事务的实现由代理对象管理。在上面的代码中，直接使用方法名称调用方法B，实际是<code>this.getResult()</code>，没有通过代理对象调用，因此方法B的事务不会生效。</p><h4 id="4-对该问题的解决"><a href="#4-对该问题的解决" class="headerlink" title="4. 对该问题的解决"></a>4. 对该问题的解决</h4><p>&emsp; 若想解决事务失效的问题，首先需要获取到本类的代理对象，随后通过代理对象调用方法B。具体代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法A</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().intern();</span><br><span class="line">        <span class="keyword">synchronized</span>(userId.toString().intern()) &#123;</span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.getResult(voucherId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法B</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getResult</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">// 包含了判断用户是否下过单以及对两个数据库的修改</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="四、分布式锁"><a href="#四、分布式锁" class="headerlink" title="四、分布式锁"></a>四、分布式锁</h2><h3 id="4-1-服务器集群模式下的线程安全问题"><a href="#4-1-服务器集群模式下的线程安全问题" class="headerlink" title="4.1 服务器集群模式下的线程安全问题"></a>4.1 服务器集群模式下的线程安全问题</h3><h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h4><p>&emsp; 由于每一个jvm都有自己的锁监视器，因此当后端服务器是集群模式的情况时，同一时刻同一用户不同线程访问不同的后端服务器，都会获得锁，故针对“一人一单”的锁就会失效。</p><h4 id="2-使用redis实现分布式锁"><a href="#2-使用redis实现分布式锁" class="headerlink" title="2. 使用redis实现分布式锁"></a>2. 使用redis实现分布式锁</h4><p>&emsp; 使用redis的setnx命令即可实现分布式锁，下面是一个使用redis实现分布式锁的样例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> ID_PREFIX +  Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + key, value, timeoutSec, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">myLock</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisLock</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (myLock.equals(redisLock)) &#123;</span><br><span class="line">            stringRedisTemplate.delete(KEY_PREFIX + key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp; 在该分布式锁的实现过程中，需要注意一下几个问题：</p><ul><li>设置锁的超时施放时间，可以防止因线程拿到锁后迟迟不释放锁导致出现死锁的问题。</li><li>使用随机前缀 + 线程ID作为锁的value，原因有两个：<ul><li>当线程需要释放锁时，首先获取锁的value，与自己的线程ID作比较，可以判断自己的锁是否已经释放，防止误释放其他线程锁的情况</li><li>由于后端是集群模式，因此线程ID可能会有重复，因此需要随机前缀保证不同后端服务器的不同线程保存锁的value值不重复</li></ul></li></ul><h4 id="3-实现过程中的问题及解决"><a href="#3-实现过程中的问题及解决" class="headerlink" title="3. 实现过程中的问题及解决"></a>3. 实现过程中的问题及解决</h4><ul><li>由于在释放锁时，判断锁的value和自己现成的id是否相等与释放锁的操作不是原子性的，因此可能会出现线程安全问题<ul><li>使用lua脚本可以实现对redis操作的原子性，代码实现如下：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line">end</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在上述分布式锁代码的基础上的修改和添加</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.execute(UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + key),</span><br><span class="line">                ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-redisson工具"><a href="#4-2-redisson工具" class="headerlink" title="4.2 redisson工具"></a>4.2 redisson工具</h3><h4 id="1-书写的redis分布式锁的缺点"><a href="#1-书写的redis分布式锁的缺点" class="headerlink" title="1. 书写的redis分布式锁的缺点"></a>1. 书写的redis分布式锁的缺点</h4><ul><li>不可重入：同一个线程无法多次获取同一把锁</li><li>不可重试：获取锁失败就会返回false，没有重试机会</li><li>超时释放：线程任务未完成也会释放锁，存在安全隐患</li><li>主从一致性：redis集群可能会导致锁被多个线程获取，当然这种可能性极低</li></ul><h4 id="2-redisson的使用"><a href="#2-redisson的使用" class="headerlink" title="2. redisson的使用"></a>2. redisson的使用</h4><p>&emsp; redisson提供了一系列分布式的java常用对象，其中包括各种分布式锁的实现，下面是使用redisson的步骤：</p><ul><li>引入redisson依赖<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>配置redisson客户端<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.223.101:6379&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用redissonClient调用redisson方法</li></ul><h4 id="3-redisson解决上述四个问题的原理"><a href="#3-redisson解决上述四个问题的原理" class="headerlink" title="3. redisson解决上述四个问题的原理"></a>3. redisson解决上述四个问题的原理</h4><ul><li>可重入：<ul><li>redisson使用redis的hash数据解决来存储一把锁，当一个线程获取锁成功时，会将hash的value + 1，hash结构中的value代表该锁被获取的个数。</li></ul></li></ul><img src="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%AD/image-12.png" class="" title="redisson锁"><ul><li><p>可重试：</p><ul><li>使用redis的消息订阅以及信号量的机制实现。当获取锁失败，线程会在自己设置的等待时间内等待其他线程释放锁，若该时间段内其他现车给释放了锁，则会使用消息队列的机制发送给当前线程一条消息，该线程就可以再次尝试获取锁；否则将会返回false。</li></ul></li><li><p>不会超时释放</p><ul><li>当调用获取锁的方法时，如果给leaseTime赋值，那么会开启Watchdog机制，该机制可以无限期给当前线程任务重置超时时间直到锁释放</li></ul></li></ul><img src="/2024/08/09/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%AD/image.png" class="" title="alt text"><ul><li>主从一致性分布式锁<ul><li>当redis是主从集群模式时，需要使用multiLock，该方法需要获取所有独立的redis节点上的锁，才算获取锁成功</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 项目经历 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马点评项目总结(上)</title>
      <link href="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/"/>
      <url>/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="黑马点评项目技术总结"><a href="#黑马点评项目技术总结" class="headerlink" title="黑马点评项目技术总结"></a>黑马点评项目技术总结</h1><h2 id="一、基于Redis实现发送短信验证码功能"><a href="#一、基于Redis实现发送短信验证码功能" class="headerlink" title="一、基于Redis实现发送短信验证码功能"></a>一、基于Redis实现发送短信验证码功能</h2><h3 id="1-1-基于session实现发送短信验证码功能流程"><a href="#1-1-基于session实现发送短信验证码功能流程" class="headerlink" title="1.1 基于session实现发送短信验证码功能流程"></a>1.1 基于session实现发送短信验证码功能流程</h3><h4 id="1-发送短信验证码"><a href="#1-发送短信验证码" class="headerlink" title="1. 发送短信验证码"></a>1. 发送短信验证码</h4><p>  若用户使用手机号 + 短信验证码的方式进行登录，当用户点击获取验证码时，会向后台发送一条请求，下图就是后台对该请求的处理流程：</p><ol><li>校验手机号</li><li>生成验证码</li><li>保存验证码到session(用于后续校验)</li><li>发送验证码到用户手机  <img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-1.png" class="" title="图片"></li></ol><h4 id="2-短信验证码登录、注册"><a href="#2-短信验证码登录、注册" class="headerlink" title="2. 短信验证码登录、注册"></a>2. 短信验证码登录、注册</h4><p>  这一步是用户点击登录按钮发送到后端的请求，后端对该请求的处理流程，具体如下：</p><ol><li>校验手机号(这一步是防止用户在登陆前修改手机号)</li><li>根据第一步保存到session的验证码与前端发送的验证码比对</li><li>判断用户是否已注册</li><li>将用户保存到session中，为后续其他网页的校验做准备  <img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-2.png" class="" title="alt text"></li></ol><h4 id="3-校验登陆状态"><a href="#3-校验登陆状态" class="headerlink" title="3. 校验登陆状态"></a>3. 校验登陆状态</h4><p>  为了实现对用户的每一个页面访问进行校验的功能，此时需要用到拦截器，在拦截器中对http请求携带的cookie以及保存在session中的信息进行比较。拦截器的实现以及拦截器和过滤器的区别将在后文进行说明。<br>  若存在用户，则将脱敏后的用户信息保存到ThreadLocal中，由于每一个session都是一个线程，因此只要不关闭页面，那么以后每次对后端的请求都可以从ThreadLocal中获取本次session的用户信息。<br>  <img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-3.png" class="" title="alt text"></p><h3 id="1-2-集群的session的共享问题"><a href="#1-2-集群的session的共享问题" class="headerlink" title="1.2 集群的session的共享问题"></a>1.2 集群的session的共享问题</h3><h4 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h4><p>  由于session时保存在后端服务器内存中，且多台服务器无法共享session。因此这在实际的后端服务器集群模式下，会产生用户在服务器A登录保存到session登陆凭证，再次访问服务器B时无法得到登录的信息凭证的问题。</p><h4 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h4><p>  为解决集群下session的共享问题，设计的方案需要满足以下几点要求：</p><ol><li>数据共享</li><li>内存存储</li><li>key-value结构</li></ol><p>  redis恰好满足上述所有的要求，因此使用redis来保存验证码信息以及用户登录的authorization。</p><h4 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3. 具体实现"></a>3. 具体实现</h4><p>  将保存到session中的验证码和用户登录的authorization保存到redis中即可，同时用户每一次对网站的访问，都会刷新登录的authorization的有效期；在用户登陆成功后，及时将登陆的验证码从redis中删除。</p><h3 id="附：拦截器的实现"><a href="#附：拦截器的实现" class="headerlink" title="附：拦截器的实现"></a>附：拦截器的实现</h3><ol><li><p>创建一个类实现HandlerInterceptor接口，重写preHandle方法，afterCompletion可根据需求自定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个实现WebMvcConfigurer接口的类，重写其中的addInterceptors方法，该类中可以配置所有的拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意不要忘记注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span></span><br><span class="line">                )</span><br><span class="line">                .order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// order越小越靠前</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="二、商户查询缓存"><a href="#二、商户查询缓存" class="headerlink" title="二、商户查询缓存"></a>二、商户查询缓存</h2><h3 id="2-1-缓存前置"><a href="#2-1-缓存前置" class="headerlink" title="2.1 缓存前置"></a>2.1 缓存前置</h3><h4 id="1-缓存的作用"><a href="#1-缓存的作用" class="headerlink" title="1. 缓存的作用"></a>1. 缓存的作用</h4><ul><li>降低后端负载</li><li>提高读写效率、降低延迟时间</li></ul><h4 id="2-缓存的成本"><a href="#2-缓存的成本" class="headerlink" title="2. 缓存的成本"></a>2. 缓存的成本</h4><ul><li>数据一致性成本</li><li>代码维护成本</li><li>运维成本</li></ul><p>本项目对查询的店铺信息添加的缓存，降低了访问店铺的响应时间</p><h3 id="2-2-缓存更新策略"><a href="#2-2-缓存更新策略" class="headerlink" title="2.2 缓存更新策略"></a>2.2 缓存更新策略</h3><p>&emsp; 当数据更新到数据库时，如何保证缓存中的数据与数据库中的数据保持一致性，此时需要考虑缓存的更新策略，一般有如下三种缓存更新策略：</p><img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-4.png" class="" title="alt text"><ul><li>当一致性需求低时，可以考虑使用redis自带的内存淘汰机制</li><li>若需要高一致性需求，则可以使用主动更新，配合超时剔除作为兜底方法</li></ul><p>&emsp; 当使用主动更新策略时，需要注意以下<strong>三个问题</strong>：</p><ul><li><em>数据更新时，删除缓存还是更新缓存？</em><ul><li>应该选择<strong>删除缓存</strong>，当查询数据时再将数据从数据库中读入缓存中，这样可以避免更新是对缓存无效的写操作。</li></ul></li><li>如何保证缓存与数据库的操作同时成功或者失败？<ul><li>当项目是单体项目时，将对缓存和数据库的操作放在一个事务内；</li><li>若时分布式系统，则可以采用分布式事务解决方案。</li></ul></li><li>先操作缓存还是数据库？<ul><li>先操作数据库随后再删除缓存。由于对数据的操作耗时较长，当删除缓存后，有另一个线程需要访问该数据，此时会向缓存中写入还未更新的数据，导致缓存和数据库的数据不一致</li></ul></li></ul><h3 id="2-3-缓存穿透"><a href="#2-3-缓存穿透" class="headerlink" title="2.3 缓存穿透"></a>2.3 缓存穿透</h3><h4 id="1-什么是缓存穿透"><a href="#1-什么是缓存穿透" class="headerlink" title="1. 什么是缓存穿透"></a>1. 什么是缓存穿透</h4><p>&emsp; 客户端请求的数据在缓存和数据库中都不存在，这会使得缓存永远不生效，所有请求都会到数据库层操作，给数据库带来巨大压力。</p><h4 id="2-解决方案-1"><a href="#2-解决方案-1" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h4><img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-5.png" class="" title="alt text"><ul><li><p>缓存空对象</p><ul><li>对于缓存击穿查询的对象也保存一份空对象到缓存中，这样以后的请求就可以从缓存中查到</li><li>优点：<ul><li>实现简单，维护方便</li></ul></li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的数据不一致性，当缓存中的数据是空对象时，此时恰好为插入了一条该数据到数据库中。</li></ul></li></ul></li><li><p>布隆过滤</p><ul><li>在请求redis缓存前，先到布隆过滤器中查询是否有该数据，如果没有则拒绝本次请求 <em>（算法在附录中）</em></li><li>优点：<ul><li>内存占用较少</li></ul></li><li>缺点：<ul><li>实现复杂</li><li>存在误判的可能，会出现不存在的数据被误判为存在</li></ul></li></ul></li><li><p>增加id的复杂度，避免被猜测id的规律</p></li><li><p>做好数据的基础格式校验</p></li></ul><h3 id="2-4-缓存雪崩"><a href="#2-4-缓存雪崩" class="headerlink" title="2.4 缓存雪崩"></a>2.4 缓存雪崩</h3><h4 id="1-什么是缓存雪崩？"><a href="#1-什么是缓存雪崩？" class="headerlink" title="1. 什么是缓存雪崩？"></a>1. 什么是缓存雪崩？</h4><p>&emsp; 同一时间段内缓存中的大量key同时失效或者redis服务器宕机，导致大量请求到达数据库</p><h4 id="2-解决方案-2"><a href="#2-解决方案-2" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h4><ul><li>给不同的key添加随机的TTL值，可以防止redis中的key同时失效</li><li>利用redis集群提高服务的可用性</li><li>添加多级缓存</li><li>给业务添加降级限流策略</li></ul><h3 id="2-5-缓存击穿"><a href="#2-5-缓存击穿" class="headerlink" title="2.5 缓存击穿"></a>2.5 缓存击穿</h3><h4 id="1-什么是缓存击穿"><a href="#1-什么是缓存击穿" class="headerlink" title="1. 什么是缓存击穿"></a>1. 什么是缓存击穿</h4><p>&emsp; 也称热点key问题，一个被<strong>高并发访问</strong>且<strong>缓存重建困难</strong>的key失效，导致大量的请求被发送到数据库，且同时进行大量的缓存重建操作</p><h4 id="2-解决方案-3"><a href="#2-解决方案-3" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h4><ul><li>互斥锁<ul><li>第一个查询到缓存失效的线程获取到锁并对数据进行缓存重建，其他线程无法获取到锁进行休眠</li><li>优点<ul><li>没有额外的内存损耗</li><li>保证一致性</li><li>实现简单</li></ul></li><li>缺点<ul><li>其他没有获取到锁的线程需要等待，效率降低<img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-8.png" class="" title="互斥锁"></li></ul></li></ul></li><li>逻辑过期<ul><li>每一条热点数据实际上在内存中永不过期，但会存储一个逻辑过期时间。当查询到逻辑过期时间到期后，会开启一个线程进行异步缓存重建，缓存重建期间对该数据的所有查询都会返回旧值。</li><li>优点<ul><li>线程无需等待，性能较好</li></ul></li><li>缺点<ul><li>缓存重建期间，查询的数据不保证一致性</li><li>异步重建缓存会造成一定的内存损耗</li><li>实现复杂<img src="/2024/08/07/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%B8%8A/image-9.png" class="" title="逻辑过期"></li></ul></li></ul></li><li><strong>互斥锁的实现</strong><ul><li>使用redis中的setnx即可</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 项目经历 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/08/06/test%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/08/06/test%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="test-第一篇文章"><a href="#test-第一篇文章" class="headerlink" title="test 第一篇文章"></a>test 第一篇文章</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
